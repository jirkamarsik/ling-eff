\chapter{Composing the Effects}
\label{chap:composing-effects}

In Chapters~\ref{chap:introducing-effects}
and~\ref{chap:dynamic-semantics}, we have seen $\calc$ analyses of
deixis~(\ref{sec:deixis}), conventional
implicature~\ref{sec:conventional-implicature},
quantification~(\ref{sec:quantification}), anaphora~(\ref{sec:banana-drt})
and presupposition~(\ref{sec:presuppositions}). All of those analyses
shared the same structure: constituents of atomic abstract type were
interpreted as $\calc$ computations.\footnote{Note though that in
  Chapter~\ref{chap:introducing-effects}, we had $\sem{S} = \FF_E(o)$ and
  after the shift to dynamic semantics in
  Chapter~\ref{chap:dynamic-semantics}, we switched to
  $\sem{S} = \FF_E(1)$.} The fact that there is a common underlying
structure present in all of these phenomena has already been discovered by
the pioneers of monads in natural language
semantics~\cite{shan2002monads,charlow2014semantics,giorgolo2015natural,barker2015monads}. However,
the point of expressing all of these phenomena in a single framework is not
just to have a uniform set of fragments, but to also be able to combine
those fragments into a wider picture.

Most recently, proposals for combining monads in natural language semantics
have started
appearing~\cite{charlow2014semantics,giorgolo2015natural,barker2015monads}. We
can divide them into two strategies:

\begin{itemize}
\item Constructing a ``supermonad'' that combines the structural elements
  of all the monads that we want to use.

  The denotations of constituents are then all computations within this
  monad (or their denotations are injected into this supermonad). The
  monad's $\hsbind$ operator serves as the universal glue, allowing us to
  combine any two meanings, regardless of the effects they use. This
  approach was adopted by Charlow in his
  dissertation~\cite{charlow2014semantics}.
\item Making all the necessary components to build semantic glue lexical
  items in the grammar.

  Instead of deriving a general monad that encompasses all of the necessary
  monadic structure, we include the $\eta$ and $\hsbind$ of every monad we
  want to use into our grammar. Different lexical entries will use
  different (combinations of) monads and it is one of the duties of parsing
  to find the necessary semantic glue which combines these meanings in a
  sound way. This approach was proposed by Giorgolo and Asudeh in their
  ESSLLI 2015 course~\cite{giorgolo2015natural} and by Charlow in Barker's
  ESSLLI 2015 course~\cite{barker2015monads,charlow2015monads}.
\end{itemize}

Since ACGs separate the object-level types (where we use monads and
semantic types) from the abstract-level types (where we use linear
implications and syntactic types and where we control the set of valid
syntactic structures), the latter approach becomes impractical. If we
wanted to add the monadic combinators $\eta$ and $\hsbind$ and give them
their correct types, we would need to change the logic of the
abstract-level type system, e.g.\ by including a modality for every
monad. In doing this, we would no longer be working with ACGs, but with
some other type-logical grammar formalism, and we would lose the benefit of
existing results for ACGs (e.g.\ on the complexity of
parsing~\cite{kanazawa2007parsing}). Our approach is an instance of the
former method. Our ``supermonad'' is the free monad $\FF_E$
from~\ref{ssec:monad} and~\ref{ssec:free-monad}. In contrast to the
approach used in Charlow's dissertation~\cite{charlow2014semantics}, we
explore the use of effects and handlers instead of monad transformers and
we perform all computation in a formally defined object language $\calc$,
which is an extension of the simply-typed lambda calculus.

In~\ref{sec:presuppositions}, we have already seen how to combine our
treatment of anaphora with a treatment of presuppositions. We will extend
the fragment from Chapter~\ref{chap:dynamic-semantics} with the effects
from Chapter~\ref{chap:introducing-effects} using the same process that we
have used when adding presuppositions:

\begin{enumerate}
\item We will translate any closed handlers used in lexical entries into
  open handlers. While closed handlers can often be simpler to compute
  with, they are no longer applicable in the presence of other effects. For
  an example of this process, look in~\ref{ssec:revising-dynamic-handler},
  where we translate the $\BOX$ handler, which is used in entries that make
  use of dynamic negation, into an open handler.
\item We will update the existing entries in the grammar(s) to reflect any
  interactions between the lexical entries and phenomena present in both
  treatments. In the case of presupposition, we have made it so that
  contexts can cancel
  presuppositions~(\ref{ssec:cancelling-presuppositions}) and accommodate
  presuppositions~(\ref{ssec:ambiguous-accommodation}) by modifying the
  $\BOX$ (and later $\DBOX$) handler used in dynamic negation.
\end{enumerate}


\minitoc


\section{Dynamic Kernel}
\label{sec:dynamic-kernel}

As per the methodology described in~\ref{sec:methodology}, we will start
with a basic ``seed'' grammar into which we will incorporate treatments of
diverse phenomena. The grammar that we will start with will be a small
dynamic fragment, very much like the one
in~\ref{sec:banana-drt}.\footnote{We could have also started with a more
  basic fragment without any effects and add dynamics separately. However,
  adding dynamics would force us to change almost all of the fragment:
  every individual meaning would need to add its referent to the context
  and every propositional meaning would need to add the proposition to the
  context. Furthermore, as we have seen
  in~\ref{ssec:truth-conditions-side-effects}, we would also change the
  type of sentence interpretations from $\FF_E(o)$ to $\FF_E(1)$. A very
  similar translation from a static grammar to a dynamic one is described
  in~\cite{lebedeva2012expression}~(Definition~4.27).} While
in~\ref{sec:banana-drt}, we tried to keep our dynamic grammar as close as
possible to the presentation of DRT in Kamp and Reyle's
textbook~\cite{kamp1993discourse}, the grammar that we will use here will
be more in line with the categorial tradition. Instead of using
non-lexicalized rules such as $\abs{trans} : VP \limp NP \limp NP \limp S$
and $\abs{common} : CN \limp N$ (which were standing in for the DRT
construction rules $\crlitv$ and $\crlin$), we will be using lexicalized
items such as $\abs{loves} : NP \limp NP \limp S$ and $\abs{man} : N$.

We first give the lexical items in our grammar and their syntactic types
(i.e.\ the abstract signature).

\begin{align*}
  \abs{she}, \abs{he}, \abs{it} &: NP \\
  \abs{a} &: N \limp NP \\
  \abs{man}, \abs{woman}, \abs{Porsche}, \abs{Mercedes} &: N \\
  \abs{loves}, \abs{owns}, \abs{fascinates} &: NP \limp NP \limp S \\
  \abs{not-the-case} &: S \limp S \\
  \abs{and}, \abs{if-then}, \abs{either-or} &: S \limp S \limp S \\
  \abs{\_.\_} &: D \limp S \limp D \\
  \abs{nil} &: D
\end{align*}

This grammar is about dynamic semantics and anaphora. Therefore, it
contains indefinites (indefinite article + common nouns) and pronouns to
showcase the introduction and retrieval of discourse referents. It also
contains entries for verbs which let use these noun phrases inside of
sentences. One of the key issues of dynamic semantics is how anaphora
interacts with logical operators. For these purposes, we include in our
grammar lexical items corresponding to constructions that mimic the logical
operators of negation, conjunction, implication and disjunction. Finally,
dynamic semantics studies how anaphora works across sentences, through a
discourse. We treat discourse as a list of sentences. We introduce an
atomic abstract type $D$ of discourses, an empty discourse $\abs{nil} : D$
and a discourse extension operator $\abs{\_.\_} : D \limp S \limp D$.

We will now give a semantic interpretation to the abstract language
generated by these items. First, we define the object signature that will
be the target of our interpretation.

\begin{align*}
  \top, \bot &: o \\
  \lnot &: o \to o \\
  (\_ \land \_), (\_ \to \_), (\_ \lor \_) &: o \to o \to o \\
  \exists, \forall &: (\iota \to o) \to o \\
  \_ = \_ &: \iota \to \iota \to o \\
  \obj{man}, \obj{woman}, \obj{Porsche}, \obj{Mercedes} &: \iota \to o \\
  \obj{love}, \obj{own}, \obj{fascinate} &: \iota \to \iota \to o \\
  \nil &: \gamma \\
  \_ \cons \_ &: \iota \to \gamma \to \gamma \\
  \_ \cons \_ &: o \to \gamma \to \gamma \\
  \_ \cat \_ &: \gamma \to \gamma \to \gamma \\
  \selhe, \selshe, \selit &: \gamma \to \iota
\end{align*}

We will have a type $o$ of propositions, which will be built out of
first-order logic (FOL) formulas. We include constants for all FOL
constructors: tautology ($\top$), contradiction ($\bot$), negation
($\lnot$), conjunction ($\land$), implication ($\to$), disjunction
($\lor$), existential quantification ($\exists$), universal quantification
($\forall$), equality on terms ($=$), unary predicates (corresponding to
common nouns) and binary predicates (corresponding to transitive verbs). We
aim to treat anaphoric binding but not anaphora resolution, and so we
introduce constants for operations that will perform anaphora resolution:
the oracles $\selhe$, $\selshe$ and $\selit$.\footnote{In
  Chapter~\ref{chap:dynamic-semantics}, we presented a simplified account
  of DRT that omitted gender features. We add them back in a limited form
  to make the examples more comprehensible.} The anaphora resolution
operators work on contexts, which contain all the knowledge in the common
ground and all individuals available for discussion. These contexts, of
type $\gamma$, are built up using $\nil$, $\cons$ and $\cat$, where $\cons$
is overloaded to work both for individuals and propositions.

Now that we have defined the object signature into which we want to
interpret our abstract language, we are ready to lay down the
lexicon. We interpret the atomic abstract types as computations:

\begin{align*}
  \sem{NP} &= \FF_E(\iota) \\
  \sem{N} &= \FF_E(\iota \to o) \\
  \sem{S} &= \FF_E(1) \\
  \sem{D} &= \FF_E(1)
\end{align*}

The effect signature $E$ is the DRT effect signature
from~\ref{ssec:dynamic-negation}

\begin{align*}
  E = \{\ &\typedop{get}{1}{\gamma}, \\
          &\typedop{introduce}{1}{\iota}, \\
          &\typedop{assert}{o}{1}\ \}
\end{align*}

The interpretation of the constants in our abstract signature is given
next:

\begin{align*}
  \lex{she}{\begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\etaE{(\selshe(e))}})}
    \end{aligned}} \\
  \lex{he}{\begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\etaE{(\selhe(e))}})}
    \end{aligned}} \\
  &\vdots \\
  \lex{a}{\begin{aligned}[t]
      \lam{N}{&\app{\op{introduce}}{\star}{(\lam{x}{ \\
              &N \hsbind (\lam {n}{ \\
              &\app{\op{assert}}{(\ap{n}{x})}{(\lam{\_}{ \\
              &\etaE{x}})}})})}}
    \end{aligned}} \\
  \lex{man}{\etaE{\obj{man}}} \\
  \lex{woman}{\etaE{\obj{woman}}} \\
  &\vdots \\
  \lex{loves}{\lam{O S}{(\obj{love} \apr S \aplr O) \hsbind \op{assert}!}} \\
  \lex{owns}{\lam{O S}{(\obj{own} \apr S \aplr O) \hsbind \op{assert}!}} \\
  &\vdots \\
  \lex{not-the-case}{\lam{A}{\dnot A}} \\
  \lex{and}{\lam{A B}{A \dand B}} \\
  \lex{if-then}{\lam{A B}{A \dimp B}} \\
  \lex{either-or}{\lam{A B}{A \dor B}} \\
  \lex{\_.\_}{\lam{D S}{D \hsbind (\lam{\_}{S})}} \\
  \lex{nil}{\etaE{\star}}
\end{align*}

The interpretations are almost the same as the ones given
in~\ref{sec:banana-drt}, with the following changes:

\begin{itemize}
\item We use the simplified entry for pronouns, derived
  in~\ref{ssec:algebraic-drt}, to which we add gender markings.
\item We also give interpretations to the two new constants, $\_.\_$ and
  $\abs{nil}$. We interpret the empty discourse $\abs{nil}$ as a discourse
  which contributes nothing, a trivial computation that immediately returns
  the dummy value $\star$. The discourse extension operator $\_.\_$ is
  interpreted the same as the dynamic conjunction $\dand$, by chaining the
  evaluation of its constituents.
\end{itemize}

In the interpretations, we make use of \emph{dynamic} logical operators
that work with propositions of type $\FF_E(1)$, most of which we have seen
in Chapter~\ref{chap:dynamic-semantics}. Below, we give the definition for
the complete set of first-order dynamic logical operators:

\begin{align*}
  A \dand B &= A \hsbind (\lam{\_}{B}) \\
  \dnot A &= \ap{\BOX}{A} \hsbind (\lam{a}{\ap{\op{assert}!}{(\lnot a)}}) \\
  \dexists x.\,A &= \app{\op{introduce}}{\star}{(\lam{x}{A})} \\
  A \dimp B &= \dnot (A \dand \dnot B) \\
  A \dor B &= \dnot (\dnot A \dand \dnot B) \\
  \dforall x.\,A &= \dnot (\dexists x.\,\dnot A)
\end{align*}

From their definitions, we can glean some of the dynamic characteristics of
these operators:

\begin{itemize}
\item In $A \dand B$, the effects of $A$ combine with and scope over the
  effects of $B$. The discourse referents introduced by $A$ are therefore
  accessible in $B$, i.e.\ $\dand$ is an \emph{internally dynamic}
  operator.
\item The existential quantifier
  $\dexists : (\iota \to \FF_E(1)) \to \FF_E(1)$ uses the $\op{introduce}$
  operation to scope over its continuation. This, in combination with the
  previous fact, allows us to derive the key equation of Dynamic Predicate
  Logic~\cite{groenendijk1991dynamic}
  $(\dexists x.\,A) \dand B = (\dexists x.\,A \dand B)$.\footnote{The
    equation follows from a single reduction using the $\op{op}.\hsbind$
    rule~(Property~\ref{prop:bind-rules}).}
\item The $\dnot A$ dynamic negation uses the $\BOX$ handler to interpret
  the dynamic operations in $A$ and therefore stop their projection. This
  makes $\dnot$ an \emph{externally static operator} since the dynamic
  effects of its argument do not project (i.e.\ are not accessible) out of
  the resulting proposition.
\item The last three operators are all headed by $\dnot$ and are therefore
  all externally static.
\item The left conjunct in the definition of $A \dor B$ is negated and
  $\dor$ is therefore internally static (discourse contributions of $A$ are
  not accessible in $B$). On the other hand, the left conjunct in the
  definition of $A \dimp B$ is not negated and $\dimp$ is therefore
  internally dynamic (as in the example ``\emph{If John owns a car$_1$,
    then it$_1$ is cheap}'').
\end{itemize}

The final piece of the puzzle is the $\BOX$ handler, which we have defined
in~\ref{ssec:revising-dynamic-handler} and which we repeat here.

\begin{align*}
  &\BOX :\FF_{E \uplus E_\DRT}(1) \to \FF_{E \uplus \{\op{get}\}}(o) \\
  &\BOX = \lam{A}{(\ap{\begin{aligned}[t]\lban
  &\onto{\op{get}}{(\lam{\_ k}{\etaE{(\lam{e}{\app{\op{get}}{\star}{(\lam{e'}{\ap{k}{(e \cat e')} \apll e})}})}})}, \\
  &\onto{\op{introduce}}{(\lam{\_ k}{\etaE{(\lam{e}{\existsr x.\ \ap{k}{x} \apll (x \cons e)})}})}, \\
  &\onto{\op{assert}}{(\lam{p k}{\etaE{(\lam{e}{p \andr (\ap{k}{\star} \apll (p \cons e))})}})}, \\
  &\onto{\eta}{(\lam{\_}{\etaE{(\lam{e}{\top})}})}\rban}{A}) \apll \nil
    \end{aligned}} \\
  \\
  &\_ \apll \_ : \FF_E(\alpha \to \FF_E(\beta)) \to \alpha \to \FF_E(\beta) \\
  &F \apll x = F \hsbind (\lam{f}{\ap{f}{x}}) \\
  &\existsr : (\iota \to \FF_E(o)) \to  \FF_E(o) \\
  &\existsr P = \exists \apr (\ap{\CC}{P})
\end{align*}

We have described the evolution of this handler in
Chapter~\ref{chap:dynamic-semantics}, so we will not go through the details
again. We will highlight just one thing, in connection to the definition of
$\dexists$ above. The $\dexists$ uses the $\op{introduce}$ operation and
the reduction rule $\op{op}.\hsbind$ tells us that operations project out
of computations
($\app{\op{op}}{M_\petitp}{(\lam{x}{M_\petitc})} \hsbind N
\to_{\op{op}.\hsbind} \app{\op{op}}{M_\petitp}{(\lam{x}{M_\petitc \hsbind
    N})}$). The $\BOX$ handler replaces the $\op{introduce}$ operation with
an existential quantifier. Using $\op{introduce}$ thus has the effect of
installing an existential quantifier at the scope of the nearest enclosing
$\BOX$, much like the DRT construction rule for indefinites, $\crid$ (see
Figure~\ref{fig:crid}), introduces a discourse referent to the nearest
enclosing DRS.

The objective of our semantics is to assign truth conditions to
sentences. These truth conditions are expressed as propositions, terms of
type $o$. As we progress, we will be adding more and more effects to
implement a compositional semantics for ``non-compositional'' phenomena
such as anaphora, presupposition and implicature. We will define a handler
that will strip away this extra structure and give us the truth conditions
of a sentence in some default context.

\begin{align*}
  \EMPTY &: \FF_{E \uplus \{\op{get}\}}(\alpha) \to \FF_E(\alpha) \\
  \EMPTY &= \banana{\onto{\op{get}}{(\lam{\_ k}{\ap{k}{\nil}})}} \\
  \TOP &: \FF_{E \uplus E_\DRT}(1) \to \FF_{E}(o) \\
  \TOP &= \EMPTY \comp \BOX \\
  \\
  \cherry \comp \TOP &: \FF_{E_\DRT}(1) \to o
\end{align*}

The $\EMPTY$ handler evaluates a meaning in the empty context $\nil$,
interpreting away the $\op{get}$ operation. On the other hand, the $\BOX$
handler interprets away the $\op{introduce}$ and $\op{assert}$ operations,
and so by composing them, we can interpret away all the effects in
$E_\DRT$. The resulting handler, $\TOP$, plays the role of a top-most
(top-level) DRS: it is a $\BOX$ in an $\EMPTY$ context (i.e.\ there is no
other DRS that is accessible from this one).

Furthermore, if we look at the special case of the type of $\TOP$ when
$E = \emptyset$, we get a pure computation (type $\FF_\emptyset(o)$) as the
result. This means we can use the $\cherry$ operator to get at the
resulting proposition directly. The $\cherry \comp \TOP$ combinator
(pronounced ``cherry on top'') gives us a formal way to associate a
proposition to the denotation of a sentence or discourse (remember that
$\sem{S} = \sem{D} = \FF_E(1)$ with $E$ currently being $E_\DRT$).

We will now integrate the effects that we have seen in
Chapters~\ref{chap:introducing-effects} and~\ref{chap:dynamic-semantics}
into our dynamic grammar. We will start with the effect that we have
already seen interact with anaphora in Section~\ref{sec:presuppositions}.


\section{Adding Presuppositions}
\label{sec:adding-presuppositions}

We will be enriching our fragment with the following referring expressions:
proper names such as \emph{John} and \emph{Mary}, possessive constructions
expressing ownership or other relations (\emph{$X$'s car}, \emph{$X$'s
  children}, \emph{$X$'s best friend}\ldots) and definite descriptions
(\emph{the car}). Here are the new entries into our abstract signature:

\begin{align*}
  \abs{John}, \abs{Mary} &: NP \\
  \abs{poss} &: NP \limp N \limp NP \\
  \abs{children}, \abs{best-friend} &: NP \limp NP \\
  \abs{the} &: N \limp NP
\end{align*}

In order to give a meaning to these constructions, we will need some extra
structure in our model. We will therefore add the following into our
object signature:

\begin{align*}
  \obj{John}, \obj{Mary} &: \iota \to o \\
  \obj{children}, \obj{best-friend} &: \iota \to \iota \to o \\
  \selP &: (\iota \to o) \to \gamma \to \iota
\end{align*}

We represent proper names in our models as predicates. The idea behind a
predicate such as $\obj{John}$ is that $\ap{\obj{John}}{x}$ should be true
for any $x$ which is called John.

Now we can describe how we extend our lexicon so that it covers the new
constructions. The interpretation of the abstract types will stay the same,
we will only change the effect signature to include the following two
operations:

\begin{align*}
\op{presuppose} &: (\iota \to o) \rightarrowtail \iota \\
\op{amb} &: 1 \rightarrowtail 2
\end{align*}

We extend the lexicon to the new constructions, using the new
$\op{presuppose}$ operation.

\begin{align*}
  \lex{John}{\ap{\op{presuppose}!}{\obj{John}}} \\
  \vdots \\
  \lex{poss}{\lam{X N}{X \hsbind (\lam{x}{N \hsbind (\lam{n}{\ap{\op{presuppose}!}{(\lam{y}{\ap{n}{y} \land \app{\obj{own}}{x}{y}})}})})}} \\
  \lex{children-of}{\lam{X}{X \hsbind (\lam{x}{\ap{\op{presuppose}!}{(\lam{y}{\app{\obj{children}}{y}{x}})}})}} \\
  \vdots \\
  \lex{the}{\lam{N}{N \hsbind (\lam{n}{\ap{\op{presuppose}!}{n}})}}
\end{align*}

These entries are the same as the ones we have seen in
Section~\ref{sec:presuppositions}. Besides introducing interpretations for
the new lexical items, we will also modify some of the existing
interpretations or combinators to reflect the interactions between the
existing effects and the effect being added. In this chapter, whenever we
will revise the interpretations of existing lexical items or the
definitions of existing combinators, we will use the $\coloneqq$ symbol and
if the right-hand side of the definition will make use of any of the
symbols being redefined, those symbols will be meant to refer to the
existing (old) definition.

\begin{align*}
  \TOP &: \FF_{E \uplus E_\DRT \uplus \{\op{presuppose}, \op{amb}\}}(1) \to \FF_{E}(o) \\
  \TOP &\coloneqq \search \comp \TOP \comp \accommodate \comp \useFind \\
       &= \search \comp \EMPTY \comp \BOX \comp \accommodate \comp \useFind \\
  \BOX &: \FF_{E \uplus E_\DRT \uplus \{\op{presuppose}\}}(1) \to \FF_{E \uplus \{\op{get}, \op{presuppose}, \op{amb}\}}(o) \\
  \BOX &\coloneqq \BOX \comp \maybeAccommodate \comp \useFind \\
\end{align*}

The changes proposed above account for the following features of
presuppositions:

\begin{itemize}
\item we add $\useFind$ to all boxes ($\BOX$), including also the topmost
  one ($\TOP$), so that presuppositional expressions referring to entities
  already available in the context do not trigger presuppositions
\item we add $\maybeAccommodate$ to the $\BOX$ handler because a
  presupposition can be accommodated in any DRS on the projection line from
  the point where the presupposition was triggered
\item we add $\accommodate$ to the $\TOP$ handler because we want any
  presuppositions that have been neither cancelled nor (locally)
  accommodated to be accommodated at the top level
\item we add $\search$ to the $\TOP$ handler so that the proposition that
  we recover is the most preferred available reading of the sentence
  (w.r.t.\ the presupposition accommodation ambiguity
  in~\ref{ssec:ambiguous-accommodation})
\end{itemize}

Below, we give the definition of the handlers for the new $\op{presuppose}$
which account for the ways a presupposition can be eliminated: global
accommodation ($\accommodate$), local accommodation ($\maybeAccommodate$)
or cancellation ($\useFind$).

\begin{align*}
  \accommodate &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to \FF_E(\alpha) \\
  \accommodate &= \banana{\onto{\op{presuppose}}{(\lam{P k}{
    \app{\op{introduce}}{\star}{(\lam{x}{\app{\op{assert}}{(\ap{P}{x})}{(\lam{\_}{\ap{k}{x}})}})}})}} \\
  \maybeAccommodate &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to
                      \FF_{E \uplus \{\op{presuppose},\op{amb}\}}(\alpha) \\
  \maybeAccommodate &= \banana{\onto{\op{presuppose}}{(\lam{P k}{
    \app{\op{presuppose}}{P}{k} +
    \app{\op{introduce}}{\star}{(\lam{x}{\app{\op{assert}}{(\ap{P}{x})}{(\lam{\_}{\ap{k}{x}})}})}})}} \\
  \useFind &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to \FF_{E \uplus \{\op{get}, \op{presuppose}\}}(\alpha) \\
  \useFind &= \banana{\onto{\op{presuppose}}{(\lam{P k}{\ap{\find}{P} \hsbind k})}}
\end{align*}

These all come from Section~\ref{sec:presuppositions}, as well as the
definitions of $\find$ and $+$ given below.

\begin{align*}
  \find &: (\iota \to o) \to \FF_{E \uplus \{\op{get}, \op{presuppose}\}}(\iota) \\
  \find &= \lam{P}{\app{\op{get}}{\star}{(\lam{e}{\case{\selP(P, e)}{x}{\etaE{x}}{\_}{\ap{\op{presuppose}!}{P}}})}} \\
  \_+\_ &: \FF_{E \uplus \{\op{amb}\}}(\alpha) \to \FF_{E \uplus \{\op{amb}\}}(\alpha) \to \FF_{E \uplus \{\op{amb}\}}(\alpha) \\
  M + N &= \app{\op{amb}}{\star}{(\lam{b}{\ifte{b}{M}{N}})}
\end{align*}

Finally, we give the handler for the $\op{amb}$ effect.

\begin{align*}
  \search &: \FF_{E \uplus \{\op{amb}\}}(\alpha) \to \FF_E(\alpha) \\
  \search &= \banana{\onto{\op{amb}}{(\lam{\_ k}{\ap{k}{\true};\ \ap{k}{\false}})}}
\end{align*}

This uses the $M; N$ notation, whose typing and reduction rules were given
in Definition~\ref{def:semi-typing-rule} and
Definition~\ref{def:semi-reduction-rule}, respectively.


\section{Adding Conventional Implicature}
\label{sec:adding-conventional-implicature}

We move to conventional implicature, which we have treated (in isolation)
in Section~\ref{sec:conventional-implicature}. We consider conventional
implicatures triggered by supplements: nominal appositives and
supplementary relative clauses. We will use the same abstract constants as
in Section~\ref{sec:conventional-implicature}, $\abs{who}_{\abs{s}}$ and
$\abs{appos}$. The constant $\abs{who}_{\abs{s}}$ stands for the
supplementary (appositive) use of the relative pronoun \emph{who}.

\begin{align*}
  \abs{who}_{\abs{s}} &: (NP \limp S) \limp NP \limp NP \\
  \abs{appos} &: NP \limp NP \limp NP
\end{align*}

We will not be adding any new predicates or operators to the object level:
the new lexical items represent new syntactic structures and function
words, not new concepts.

\begin{align*}
  \sem{\abs{who}_{\abs{s}}} &= \lam{C X}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\asImplicature}{(\ap{C}{(\etaE{x})})} \hsbind (\lam{\_}{ \\
      &\etaE{x}})})
    \end{aligned}} \\
  \lex{appos}{\lam{Y X}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\asImplicature}{(\app{\eq}{(\etaE{x})}{Y})} \hsbind (\lam{\_}{ \\
      &\etaE{x}})})
    \end{aligned}}} \\
  \\
  \eq &: \FF_E(\iota) \to \FF_E(\iota) \to \FF_E(1) \\
  \eq &= \lam{X Y}{X \hsbind (\lam{x}{Y \hsbind (\lam{y}{\ap{\op{assert}!}{(x = y)}})})} \\
  \eq &= \lam{X Y}{(X \eqlr Y) \hsbind \op{assert}!} \\
  \\
  \asImplicature &: \FF_{E \uplus \{\op{assert},\op{introduce}\}}(\alpha) \to
                    \FF_{E \uplus \{\op{implicate},\op{introduce^i}\}}(\alpha) \\
  \asImplicature &= \banana{\onto{\op{assert}}{\op{implicate}},\
                            \onto{\op{introduce}}{\op{introduce^i}}}
\end{align*}

Let us compare the entries for $\sem{\abs{who}_{\abs{s}}}$ and
$\sem{\abs{appos}}$ with those in
Section~\ref{sec:conventional-implicature}. The first reason for the
difference is that we now encode truth conditions as side effects: if we
evaluate the relative clause, its truth conditions are contributed to the
current context. We could separate the implicated truth conditions of the
embedded clause from the (asserted) truth conditions of the surrounding
material by wrapping the embedded clause in a $\BOX$.

$$
\sem{\abs{who}_{\abs{s}}} \stackrel{?}{=} \lam{C X}{\begin{aligned}[t]
    &X \hsbind (\lam{x}{ \\
    &\ap{\BOX}{(\ap{C}{(\etaE{x})})} \hsbind (\lam{i}{ \\
    &\app{\op{implicate}}{i}{(\lam{\_}{ \\
    &\etaE{x}})}})})
  \end{aligned}}
$$

However, if we do this, none of the discourse referents introduced within
the supplement will be available in subsequent discourse. This was the
behavior predicted for parentheticals by
Nunberg~\cite{nunberg1990linguistics}. However, in his theory of
conventional implicature~\cite{potts2005logic}, Potts opposes this view and
shows examples which seem to contradict Nunberg's position. This was
further supported by corpus studies in~\cite{anderbois2010crossing}. Here
is an example of anaphoric binding out of an appositive:\footnote{Shown
  in~\cite{anderbois2010crossing}, but, as far as we can tell, not from a
  corpus.}

\begin{exe}
  \ex John, who nearly killed a woman$_1$ with his car, visited her$_1$ in
  the hospital. \label{ex:hospital}
\end{exe}

Dynamic propositions contribute truth conditions ($\typedop{assert}{o}{1}$)
and discourse referents ($\typedop{introduce}{1}{\iota}$) to the local
context. In Section~\ref{sec:conventional-implicature}, we have introduced
the operation $\typedop{implicate}{o}{1}$ which contributes the truth
conditions of conventional implicatures to the global context. We will
complement $\op{implicate}$ with an operation
$\typedop{introduce^i}{1}{\iota}$ for introducing discourse referents of
conventional implicatures to the global context. We can now move at-issue
content into the conventional implicature layer by treating $\op{assert}$
as $\op{implicate}$ and $\op{introduce}$ as $\op{introduce^i}$, which is
exactly what the $\asImplicature$ handler does. If we review the lexical
entry for $\abs{who}_{\abs{s}}$, we see that the at-issue content of the
embedded relative clause $C$ gets treated \emph{as an implicature} in the
embedding expression ``\emph{$X$, who $C$}''.

$$
\sem{\abs{who}_{\abs{s}}} = \lam{C X}{\begin{aligned}[t]
    &X \hsbind (\lam{x}{ \\
    &\ap{\asImplicature}{(\ap{C}{(\etaE{x})})} \hsbind (\lam{\_}{ \\
    &\etaE{x}})})
  \end{aligned}}
$$

In particular in Example~\ref{ex:hospital}, the indefinite \emph{a woman}
in the sentence ``\emph{$x$ nearly killed a woman}'' uses the
$\op{introduce}$ operation to establish a new discourse referent. Upon
being used as an appositive clause, this $\op{introduce}$ turns into an
$\op{introduce^i}$, which will project to the global context, from which it
will be able to bind upcoming pronouns. Therefore we get the desired
binding in Example~\ref{ex:hospital}.

Finally, the implicatures signalled by the $\op{implicate}$ and
$\op{introduce^i}$ operations have to be resolved somewhere. We adopt the
approach of Projective DRT~\cite{venhuizen2013parsimonious} by interpreting
conventional implicatures as belonging to the topmost $\BOX$.

\begin{align*}
  \TOP &\coloneqq \TOP \circ \withImplicatures \\
  \\
  \withImplicatures &: \FF_{E \uplus E_\DRT \uplus \{\op{implicate},\op{introduce^i}\}}(\alpha) \to
                       \FF_{E \uplus E_\DRT \uplus \{\op{assert},\op{introduce}\}}(\alpha) \\
  \withImplicatures &= \banana{\onto{\op{implicate}}{\op{assert}},\
                               \onto{\op{introduce^i}}{\op{introduce}}}
\end{align*}


\subsection{Connection to the Standalone Theory}

The lexical entries and handlers introduced in this section have been quite
different from the ones introduced in
Section~\ref{sec:conventional-implicature}. This raises the issue of
whether the analysis that was done in
Section~\ref{sec:conventional-implicature} is upheld in our extension. We
will draw out the parallels between the original definitions and the new
ones to show that:

\begin{itemize}
\item the most visible changes are due to us representing truth conditions
  as side effects
\item the important change is the treatment of $\op{introduce}$ which
  accounts for the binding potentinal of appositives (an interaction
  between anaphora and conventional implicature)
\end{itemize}

We start with the appositive relative clause constructor.

\begin{align*}
  \sem{\abs{who}_{\abs{s}}} = \lam{C X}{
      &X \hsbind (\lam{x}{
 &\sem{\abs{who}_{\abs{s}}}' = \lam{C X}{
      &X \hsbind (\lam{x}{ \\
      &\ap{\asImplicature}{(\ap{C}{(\etaE{x})})} \hsbind (\lam{\_}{
     &&\ap{C}{(\etaE{x})} \hsbind (\lam{i}{ \\
      &
     &&\app{\op{implicate}}{i}{(\lam{\_}{ \\
      &\etaE{x}})})}
     &&\etaE{x}})}})})}
\end{align*}

In the standalone treatment (seen on the right), we used a static grammar,
where sentences denoted propositions. To turn the proposition into an
implicature, all we had to do was to pass that proposition to the
$\op{implicate}$ operation. In our dynamic grammar, sentences use
$\op{assert}$ to convey their truth conditions and so we need to use a
handler to pass these truth conditions to $\op{implicate}$, which is
exactly what (the $\op{assert}$ clause of) the $\asImplicature$ handler
does.

Now on to nominal appositives.

\begin{align*}
  \sem{\abs{appos}} = \lam{Y X}{
    &X \hsbind (\lam{x}{
 &\sem{\abs{appos}}' = \lam{Y X}{
    &X \hsbind (\lam{x}{ \\
    &\ap{\asImplicature}{(\app{\eq}{(\etaE{x})}{Y})} \hsbind (\lam{\_}{
   &&\app{\eq'}{(\etaE{x})}{Y} \hsbind (\lam{i}{ \\
    &
   &&\app{\op{implicate}}{i}{(\lam{\_}{ \\
    &\etaE{x}})})}
   &&\etaE{x}})}})})} \\
  \\
  \eq  &: \FF_E(\iota) \to \FF_E(\iota) \to \FF_E(1)
 &\eq' &: \FF_E(\iota) \to \FF_E(\iota) \to \FF_E(o) \\
  \eq  &= \lam{X Y}{(X \eqlr Y) \hsbind \op{assert}!}
 &\eq' &= \lam{X Y}{X \eqlr Y}
\end{align*}

We have refactored the original interpretation $\sem{\abs{appos}}'$ so that
the actual differences are easier to spot. Again, we see the same
difference as in $\abs{who}_{\abs{s}}$, where we use the $\asImplicature$
handler. The only other difference is that the condition about the equality
of the referents of $X$ and $Y$ is not expressed as a computation that
produces a proposition but as a computation that uses $\op{assert}$. This
is again due to us having switched to a dynamic grammar that treats truth
conditions as side effects.

Finally, we look at the handler, $\withImplicatures$. The original handler
from Section~\ref{sec:presuppositions} is given below:

\begin{align*}
  \withImplicatures' &: \FF_{\{\typedop{implicate}{o}{1}\}}(o) \to o \\
  \withImplicatures' &= \bbanana{\onto{\op{implicate}}{(\lam{i k}{i \land \ap{k}{\star}})}}
\end{align*}

The first step is to translate this handler into an open handler. The
continuation $k$ will now return a computation of a proposition (type
$\FF_E(o)$) and so we will use $\andr$ to conjoin the implicature $i$ to
it.

\begin{align*}
  \withImplicatures'' &: \FF_{E \uplus \{\typedop{implicate}{o}{1}\}}(o) \to \FF_E(o) \\
  \withImplicatures'' &= \banana{\onto{\op{implicate}}{(\lam{i k}{i \andr \ap{k}{\star}})}}
\end{align*}

Our dynamic grammar expresses truth conditions using side effects and so we
will replace $i : o$ with $\ap{\op{assert}!}{i} : \FF_{E_\DRT}(1)$ and
$\andr$ with $\dand$.

\begin{align*}
  \withImplicatures''' &: \FF_{E \uplus E_\DRT \uplus \{\typedop{implicate}{o}{1}\}}(\alpha)
                      \to \FF_{E \uplus E_\DRT}(\alpha) \\
  \withImplicatures''' &= \banana{\onto{\op{implicate}}{(\lam{i k}{(\ap{\op{assert}!}{i}) \dand \ap{k}{\star}})}} \\
  &= \banana{\onto{\op{implicate}}{(\lam{i k}{(\app{\op{assert}}{i}{(\lam{x}{\etaE{x}})}) \hsbind (\lam{\_}{\ap{k}{\star}})})}} \\
  &= \banana{\onto{\op{implicate}}{(\lam{i k}{\app{\op{assert}}{i}{(\lam{x}{\ap{k}{\star}})}})}} \\
  &\approx \banana{\onto{\op{implicate}}{(\lam{i k}{\app{\op{assert}}{i}{(\lam{x}{\ap{k}{x}})}})}}\footnotemark \\
  &= \banana{\onto{\op{implicate}}{(\lam{i k}{\app{\op{assert}}{i}{k}})}} \\
  &= \banana{\onto{\op{implicate}}{\op{assert}}}
\end{align*}

\footnotetext{The variable $x$ is of type $1$, which has only one value,
  $\star$. However, the set of closed normal forms of type $1$ also
  includes stuck computations. Nevertheless, our handlers for $\op{assert}$
  only ever return $\star$ as the output.}

For comparison, this is the $\withImplicatures$ handler that we use when
adding conventional implicatures to our dynamic grammar:

\begin{align*}
  \withImplicatures &: \FF_{E \uplus E_\DRT \uplus \{\op{implicate},\op{introduce^i}\}}(\alpha)
                   \to \FF_{E \uplus E_\DRT}(\alpha) \\
  \withImplicatures &= \banana{\onto{\op{implicate}}{\op{assert}},\
                               \onto{\op{introduce^i}}{\op{introduce}}}
\end{align*}

The difference between the two is the $\op{introduce}$ operation and how we
decide to deal with it. If we contain it locally, within the implicature,
we get a theory à la Nunberg~\cite{nunberg1990linguistics}, where referents
introduced in appositives are not accessible outside of the at-issue
layer. On the other hand, if we project the $\op{introduce}$ operations of
the appositives as $\op{introduce^i}$, we get a theory which licenses the
binding in Example~\ref{ex:hospital}.


\subsection{Connection to Layered DRT and Projective DRT}

Geurts and Maier~\cite{geurts2003layered} introduced \emph{Layered DRT},
wherein every discourse referent and condition is annotated with a
\emph{label} that tells us to which layer of meaning a referent/condition
belongs. The layers treated in~\cite{geurts2003layered} include the layers
of assertions, presuppositions and implicatures. The idea is that thanks to
these labels, it is possible to separate out the individual layers while
still allowing binding to work from layer to layer.

There is a close correspondence between our use of effects and layered
DRT:

\begin{itemize}
\item $\op{assert}$ adds conditions to the assertion layer
\item $\op{introduce}$ adds discourse referents to the assertion layer
\item $\op{implicate}$ adds conditions to the implicature layer
\item $\op{introduce^i}$ adds discourse referents to the implicature layer
\item $\op{presuppose}$ adds discourse referents and conditions to the
  presupposition layer
\end{itemize}

We can compare the layered DRS with the corresponding computation. Geurts
and Maier~\cite{geurts2003layered} give the following layered DRS as the
meaning of Example~\ref{ex:porridge}.

\begin{exe}
  \ex The porridge is warm. \label{ex:porridge}
\end{exe}

\begin{minipage}{.4\textwidth}
  \drs{$x_\petitp$}{
    $\obj{porridge}_\petitp(x)$ \\
    $\obj{warm}_\petita(x)$ \\
    $\lnot_\petiti$ \drs{}{
      $\obj{hot}_\petiti(x)$
    }
  }
\end{minipage}
\begin{minipage}{.4\textwidth}
  \vspace*{-4mm}
  \begin{center}
  \begin{align*}
    &\app{\op{presuppose}}{\obj{porridge}}{(\lam{p}{ \\
    &\app{\op{assert}}{(\obj{warm}(x))}{(\lam{\_}{ \\
    &\app{\op{implicate}}{(\lnot (\obj{hot}(x)))}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}
  \end{align*}
  \end{center}
\end{minipage}

\vspace*{3mm}

However, our use of distinct operation symbols for assertions, implicatures
and presuppositions was not motivated by the separation of these layers of
meaning, but by their different projectional behavior. In that, our
approach is closer to Projective DRT.\@ In Projective DRT, the DRSs are
labelled and every discourse referent and condition is annotated with a
pointer which either points to a label or is free. Assertions point to the
containing DRS while conventional implicatures point to the topmost DRS.\@
Presuppositions either to point to a local/intermediate DRS when the
presupposition is bound (``cancelled''), or they are free, in which case
they project and accommodate in the topmost DRS.

\vspace*{3mm}
\begin{minipage}{.4\textwidth}
{
  \begin{center}
  \let \drsalignment = l
  \shortstack{1 \\ \drs{$f \from x$}{
    $f \from \obj{porridge}(x)$ \\
    $1 \from \obj{warm}(x)$ \\
    $0 \from \lnot$ \shortstack{2 \\ \drs{}{
      $2 \from \obj{hot}(x)$
    }}
  }}
  \end{center}
}
\end{minipage}
\begin{minipage}{.4\textwidth}
  \begin{center}
  \begin{align*}
    &\app{\op{presuppose}}{\obj{porridge}}{(\lam{p}{ \\
    &\app{\op{assert}}{(\obj{warm}(x))}{(\lam{\_}{ \\
    &\app{\op{implicate}}{(\lnot (\obj{hot}(x)))}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}
  \end{align*}
  \end{center}
\end{minipage}
\vspace{5mm}

The correspondence between Projective DRT and our approach is similar to
the one with Layered DRT.\@ Material addressed to the global DRS $0$ is
analysed as implicature ($\op{implicate}$ and $\op{introduce^i}$), material
addressed to the DRS in which it appears is treated as assertion
($\op{assert}$ and $\op{introduce}$) and material that is addressed to some
free label $f$ is treated as presupposition ($\op{presuppose}$). Projective
DRSs might also contain pointers to labels which are neither local nor
global. These presumably correspond to bound/cancelled presuppositions,
which our approach treats by retrieving the presupposed referent from the
context. The pointers that appear next to discourse referents and
conditions faithfully describe the way that our approach will project and
accommodate them:

\begin{itemize}
\item implicatures (pointers to $0$) use $\op{implicate}$ and
  $\op{introduce^i}$ and therefore project all the way to the $\TOP$
  handler
\item assertions (pointers to the enclosing DRS) use $\op{assert}$ and
  $\op{introduce}$ and are therefore handled by the nearest enclosing
  $\BOX$ handler
\item presuppositions (free pointers) use $\op{presuppose}$ and can
  therefore be bound at any $\BOX$ thanks to the $\useFind$ handler
  (see~\ref{ssec:cancelling-presuppositions}) or accommodated at the $\TOP$
  thanks to the $\accommodate$ handler (or even accommodated lower due to
  binding constraints, see~\ref{ssec:ambiguous-accommodation})
\end{itemize}


\section{Adding Deixis}
\label{sec:adding-deixis}

We now move to our treatment of indexical expressions, namely of the
first-person pronoun. We will be enriching the abstract signature with a
new constant representing the pronoun as well as verbs for reported speech.

\begin{align*}
  \abs{me} &: NP \\
  \abs{said}_{\abs{is}} &: S \limp NP \limp S \\
  \abs{said}_{\abs{ds}} &: S \limp NP \limp S
\end{align*}

To give a meaning to reported speech, we will introduce into the object
signature a predicate $\obj{say}$:

\begin{align*}
  \obj{say} &: \iota \to o \to o
\end{align*}

Finally, we extend the lexicon, giving definitions to the new lexical
items.

\begin{align*}
  \lex{me}{\ap{\op{speaker}!}{\star}} \\
  \sem{\abs{said}_{\abs{is}}} &= \lam{C S}{(\obj{say} \apr S \aplr (\ap{\BOX}{C})) \hsbind \op{assert}!} \\
  &= \lam{C S}{S \hsbind (\lam{s}{(\ap{\BOX}{C}) \hsbind (\lam{c}{\ap{\op{assert}!}{(\app{\obj{say}}{s}{c})}})})} \\
  \sem{\abs{said}_{\abs{ds}}}
  &= \lam{C S}{S \hsbind (\lam{s}{(\app{\TOP}{s}{C}) \hsbind (\lam{c}{\ap{\op{assert}!}{(\app{\obj{say}}{s}{c})}})})} \\
  \\
  \TOP &: \iota \to \FF_{E \uplus E_\DRT \uplus \{\op{presuppose}, \op{amb}, \op{implicate}, \op{introduce^i}, \op{speaker}\}}(1) \to \FF_{E}(o) \\
  \TOP &\coloneqq \lam{s}{\TOP \comp \ap{\withSpeaker}{s}} \\
  \withSpeaker &: \iota \to \FF_{\{\typedop{speaker}{1}{\iota}\} \uplus E}(\alpha) \to \FF_E(\alpha) \\
  \withSpeaker &= \lam{s}{\banana{\onto{\op{speaker}}{(\lam{\_ k}{\ap{k}{s}})}}}
\end{align*}

The semantics of $\abs{me}$ are exactly the same as the original ones in
Section~\ref{sec:deixis} and so is the $\withSpeaker$ handler. We also
extend the $\TOP$ handler so that it still covers all the effects in our
grammar. However, unlike with the dynamics, where we could use the $\empty$
handler to supply an ``out-of-the-blue'' context, it is more difficult to
identify a default speaker. Therefore, we add an argument to $\TOP$ so that
if someone is to recover the meaning of a sentence in our growing fragment,
they will have to identify the speaker.

Finally, we will examine the entries for reported speech. Again, we have
differences due to our use of side effects to convey truth conditions:

\begin{itemize}
\item the propositions generated by the $\obj{say}$ predicate need to be
  $\op{assert}$ed
\item the quoted sentence is evaluated down to a proposition using $\BOX$
\end{itemize}

Then we have an important difference in the $\abs{said}_{\abs{ds}}$ entry
for direct speech:

\begin{itemize}
\item we want to bind the speaker to the referent of the subject, $s$,
  using $\ap{\withSpeaker}{s}$
\item we want to use $\BOX$ to evaluate the clause down to a proposition,
  same as for the $\abs{said}_{\abs{is}}$ entry
\item we do not want pronouns or other anaphoric elements within the quoted
  sentence to be bound by referents from the quoting context and so we use
  the $\EMPTY$ handler (see~\ref{sec:dynamic-kernel})\footnote{A more
    involved treatment of quotation would use anaphora to look into the
    context for the situation in which the original sentence was produced
    and evaluate the sentence in that context.}
\item we do not want the presuppositions triggered by the quoted sentence
  to be considered as presuppositions of the report and so we
  $\accommodate$ them within the scope of $\obj{say}$
\item we also do not want the same to happen for implicatures and so we use
  the $\withImplicatures$ handler to ascribe them to the person being
  quoted
\end{itemize}

In the end, what we want is to apply a handler for all of the effects that
we have introduced so far. Since we have defined the composition of all
these handlers as the combinator $\TOP$, we can use that in the lexical
entry for $\abs{said}_{\abs{ds}}$. The intuition behind it is that a
directly quoted sentence does not get to have any of its usual linguistic
effects.


\section{Adding Quantification}
\label{sec:adding-quantification}

We finish extending our fragment by adding the last of the phenomena that
we have studied in Chapter~\ref{chap:introducing-effects}, (in-situ)
quantification. We add into our fragment the determiners \emph{every} and
\emph{a},\footnote{We already have a lexical entry for the indefinite
  article from our theory of dynamics. We include another one, which will
  turn out to be equivalent in most situations, to parallel the one we had
  in Section~\ref{sec:quantification}.} as well as a genitive construction
with a relational noun\footnote{When studying presuppositions, we
  introduced entries for genitive constructions with relational nouns that
  had the syntactic type $NP \limp NP$. Those correspond to referring
  expressions such as \emph{$X$'s children} or \emph{$X$'s best
    friend}. The lexical entry $\abs{owner-of} : NP \limp N$ instead
  corresponds to the complex noun \emph{owner of $X$}, which can appear in
  expressions like \emph{the owner of $X$}, \emph{every owner of $X$},
  \emph{an owner of $X$}\ldots} (\emph{owner}) so that we can experiment
with quantifiers embedded within quantifiers.

\begin{align*}
  \abs{every}, \abs{a'} &: N \limp NP \\
  \abs{owner-of} &: NP \limp N
\end{align*}

The object signature already contains the necessary logical material to
interpret these new lexical items (logical operators and quantifiers for
the determiners and the $\obj{own}$ relation for the relational noun). To
account for how quantified noun phrases take scope over their
context, we will be using the $\op{scope}$ operator, as in
Section~\ref{sec:quantification}.

$$
\typedop{scope}{((\iota \to \FF_{E'}(1)) \to \FF_{E'}(1))}{\iota}
$$

Its type has changed from $((\iota \to o) \to o) \rightarrowtail \iota$ to
$((\iota \to \FF_{E'}(1)) \to \FF_{E'}(1)) \rightarrowtail \iota$ to
reflect the change due to using dynamic propositions $\FF_{E'}(1)$ instead
of static propositions $o$. Also note that the effect signature that we
refer to in the type of $\op{scope}$ is $E'$. Throughout this chapter, we
use $E$ to mean the effect signature containing all the effects introduced
so far. Now, we will be adding $\op{scope}$ into the effect signature
$E$. However, if we gave it the type
$((\iota \to \FF_E(1)) \to \FF_E(1)) \rightarrowtail \iota$, then we would
be giving a circular definition of $E$: $E$ is an effect signature which,
among others, contains an effect
$\typedop{scope}{((\iota \to \FF_E(1)) \to \FF_E(1))}{\iota}$, where $E$ is
an effect signature which, among others, contains an effect
$\op{scope}$\ldots. Therefore, we use a different effect signature in the
type of $\op{scope}$, one that does not contain $\op{scope}$:
$E' = E \setminus \{\op{scope}\}$.\footnote{Note that this is the same as
  the $\op{shift0}$ operation used in~\ref{sec:considering-types}, where we
  extend an existing effect signature $E$ with
  $\typedop{shift0}{((\delta \to \FF_E(\omega)) \to
    \FF_E(\omega))}{\delta}$.}

We can now give the lexical entries for the determiners and the relational
noun. These will follow the ones from Section~\ref{sec:quantification},
modulo the use of dynamic propositions (dynamic logical operators and
quantifiers, $\op{assert}$).

\begin{align*}
  \lex{every}{\lam{N}{\ap{\op{scope}!}{(\lam{k}{\dforall x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dimp \ap{k}{x}})}}} \\
  \lex{a'}{\lam{N}{\ap{\op{scope}!}{(\lam{k}{\dexists x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dand \ap{k}{x}})}}} \\
  \lex{owner-of}{\lam{Y}{Y \hsbind (\lam{y}{\etaE{(\lam{x}{\app{\obj{own}}{x}{y}})}})}} \\
  \\
  \SI &: \FF_{E \uplus \{\op{scope}\}}(1) \to \FF_E(1) \\
  \SI &= \banana{\onto{\op{scope}}{(\lam{c k}{\ap{c}{k}})}} \\
  \\
  \TOP &\coloneqq \lam{s}{\ap{\TOP}{s} \circ \SI}
\end{align*}

We can check the types of $\sem{\abs{every}}$ and $\sem{\abs{a'}}$, namely
their uses of $\op{scope}$. We know that the use of $\op{scope}$ is allowed
only when its argument is guaranteed \emph{not} to use $\op{scope}$. The
continuation $k$ that we get from $\SI$ is guaranteed to be free of
$\op{scope}$ since $\SI$ will have handled any occurrences of $\op{scope}$
within before passing it to our scope-taker. The denotation of the noun $N$
can trigger its own effects, including $\op{scope}$, as in \emph{every
  owner of a car}. We have two ways to dispense with this: having the
quantifier embedded within the noun take scope either below or above the
quantifier of the determiner.

\begin{align*}
  \sem{\abs{every}_1} &= \lam{N}{\ap{\op{scope}!}{(\lam{k}{\dforall x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dimp \ap{k}{x}})}} \\
  \sem{\abs{every}_2} &= \lam{N}{\ap{\op{scope}!}{(\lam{k}{\ap{\SI}{(\dforall x.\,((N \apl x) \hsbind \op{assert}!) \dimp \ap{k}{x})}})}}
\end{align*}

We choose the entry which assigns scope that corresponds to the linear
order of the determiners within the sentence. To account for the
alternative readings, we will adopt the solution of quantifier raising
from~\ref{ssec:quantifier-ambiguity}.

We can also check that the new entry for the indefinite article $\abs{a'}$
amounts to almost the same thing as the one for $\abs{a}$:\footnote{The
  difference being that $\abs{a'}$ projects to the $\BOX$ which contains
  the nearest scope island marker $\SI$, whereas $\abs{a}$ project to the
  nearest $\BOX$.}

\begin{align*}
\ap{\SI}{(\ap{\sem{\abs{a'}}}{N})}
&= \ap{\SI}{(\ap{\op{scope}!}{(\lam{k}{\dexists x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dand \ap{k}{x}})})} \\
&= \dexists x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dand \etaE{x} \\
&\approx \dexists x.\,((N \apl x) \hsbind \op{assert}!) \dand \etaE{x} \\
&= \app{\op{introduce}}{\star}{(\lam{x}{((N \apl x) \hsbind \op{assert}!) \dand \etaE{x}})} \\
&= \app{\op{introduce}}{\star}{(\lam{x}{(N \hsbind (\lam{n}{\ap{\op{assert}!}{(\ap{n}{x})}})) \dand \etaE{x}})} \\
&= \app{\op{introduce}}{\star}{(\lam{x}{(N \hsbind (\lam{n}{\ap{\op{assert}!}{(\ap{n}{x})}})) \hsbind (\lam{\_}{\etaE{x}})})} \\
&= \app{\op{introduce}}{\star}{(\lam{x}{N \hsbind (\lam{n}{\app{\op{assert}}{(\ap{n}{x})}{(\lam{\_}{\etaE{x}})}})})} \\
&= \ap{\sem{\abs{a}}}{N}
\end{align*}

Quantified noun phrases using the $\op{scope}$ effect take scope over
all the material up to the nearest enclosing $\SI$ handler. We should
therefore modify some of the existing constructions in our grammar to use
$\SI$ to designate scope islands. Notably, we will make it so that every
tensed clause acts as a scope island by including $\SI$ in the lexical
entries of tensed verbs.

\begin{align*}
  \sem{\abs{loves}} &:= \lam{O S}{\ap{\SI}{(\app{\sem{\abs{loves}}}{O}{S})}} \\
  \sem{\abs{owns}} &:= \lam{O S}{\ap{\SI}{(\app{\sem{\abs{owns}}}{O}{S})}} \\
  \sem{\abs{said}_{\abs{is}}} &:= \lam{C S}{\ap{\SI}{(\app{\sem{\abs{said}_{\abs{is}}}}{C}{S})}} \\
  \sem{\abs{said}_{\abs{ds}}} &:= \lam{C S}{\ap{\SI}{(\app{\sem{\abs{said}_{\abs{ds}}}}{C}{S})}}
\end{align*}


\subsection{Quantifier Raising --- Inverse Scope and Crossover}
\label{ssec:crossover}

The strategy that we have used in
Subsection~\ref{ssec:quantifier-ambiguity} to deal with quantifier scope
ambiguity was to change the order of evaluation of the quantified noun
phrases. This was the case both in the first approach, which considered
adding different lexical items which evaluate their arguments in different
orders, and in the second, final approach, which used a general operator
$\abs{QR}$ to displace the evaluation of an $NP$.

However, freely changing the order of evaluation is problematic. Consider
the following sentence (from~\cite{shan2006explaining}):

\begin{exe}
  \ex[*]{His$_1$ mother likes every man$_1$. \label{ex:crossover}}
\end{exe}

Our strategy of generating an inverse scope reading by evaluating the
object first and then the subject would lead us to bind the pronoun
\emph{his} to the variable introduced by \emph{every man}. However, this is
considered unacceptable and we would therefore like to avoid doing that in
our model.

This kind of problem represents a challenge to the fundamental assumptions
behind our methodology. Anaphora forces us to evaluate the constituents in
linear order, subject first and object last, so that we do not license
cataphora from object to subject. Inverse scope forces us to evaluate the
constituents in inverse order, object first and subject last, so that the
object can take scope over the sentence before the subject does.

In our current setting, this conflict seems impossible to resolve. However,
we can find a solution by decomposing the action of a quantified noun
phrases into two steps:

\begin{enumerate}
\item The quantified noun phrase takes scope over its matrix clause
  \emph{without} making the variable anaphorically accessible. The
  quantified noun phrase is ``replaced'' by a \emph{trace}
  computation.
\item The trace is evaluated, making the variable anaphorically accessible.
\end{enumerate}

This strategy can be summarized by saying that even though a quantifier can
move out and in front of a sentence, it is its original position,
represented by a trace, which controls its anaphoric behavior.

Our denotations $\sem{\abs{a'}}$ and $\sem{\abs{every}}$ use the $\dexists$
and $\dforall$ dynamic quantifiers, where $\dforall$ is expressed in terms
of $\dnot$ and $\dexists$. The $\dexists$ quantifier itself is defined by
the $\op{introduce}$ operation.

\begin{align*}
  \dexists x.\,A &= \app{\op{introduce}}{\star}{(\lam{x}{A})} \\
  \dforall x.\,A &= \dnot (\dexists x.\,\dnot A)
\end{align*}

The $\op{introduce}$ operation is interpreted by the $\BOX$ handler as
installing an existential handler \emph{and} introducing the variable into
the context.

$$
\BOX = \ldots \banana{\ldots,\ \onto{\op{introduce}}{(\lam{\_ k}{\etaE{(\lam{e}{\existsr x.\ \ap{k}{x} \apll (x \cons e)})}})},\ \ldots} \ldots
$$

We can decompose $\op{introduce}$ into two operations, $\op{fresh}$ and
$\op{push}$, one to wrap an existential quantifier with a fresh variable
over the discourse ($\op{fresh}$) and another to add an individual into the
context ($\op{push}$).

\begin{align*}
  \op{fresh} &: 1 \rightarrowtail \iota \\
  \op{push} &: \iota \rightarrowtail 1
\end{align*}

These two operations will replace $\op{introduce}$, which is expressible as
their composition, and their interpretations replace the interpretation of
$\op{introduce}$ in the $\BOX$ handler:

\begin{align*}
  \BOX &= \ldots \lban\begin{aligned}[t]
      &\ldots, \\
      &\onto{\op{fresh}}{(\lam{\_ k}{\etaE{(\lam{e}{\existsr x.\ \ap{k}{x} \apll e})}})}, \\
      &\onto{\op{push}}{(\lam{x k}{\etaE{(\lam{e}{\ap{k}{\star} \apll (x \cons e)})}})}, \\
      &\ldots\ \rban \ldots
    \end{aligned} \\
  \\
  \op{introduce} &: 1 \to (\iota \to \FF_{E \uplus \{\op{fresh},
                    \op{push}\}}(\alpha)) \to \FF_{E \uplus \{\op{fresh},
                    \op{push}\}}(\alpha) \\
  \op{introduce} &= \lam{\_ k}{\begin{aligned}[t]
      &\app{\op{fresh}}{\star}{(\lam{x}{ \\
      &\app{\op{push}}{x}{(\lam{\_}{ \\
      &\ap{k}{x}})}})}
    \end{aligned}}
\end{align*}

We can now adjust the dynamic quantifiers so that they only introduce a
quantifier over the discourse without modifying the context.

\begin{align*}
  \dexists x.\,A &= \app{\op{fresh}}{\star}{(\lam{x}{A})} \\
  \dforall x.\,A &= \dnot (\dexists x.\,\dnot A)
\end{align*}

We can now give a new meaning to the determiners \emph{every} and \emph{a}.

\begin{align*}
  \abs{every}, \abs{a'} &: N \limp QNP \\
  \sem{QNP} &= \FF_{\{\op{scope}\}}(\FF_{E'}(\iota)) \\
  \\
  \lex{every}{\lam{N}{\begin{aligned}[t]
      &\app{\op{scope}}{(\lam{k}{\dforall x.\ \ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dimp \ap{k}{x}})}{(\lam{x}{ \\
      &\etaE{(\ap{\trace}{x})}})}
    \end{aligned}}} \\
  \lex{a'}{\lam{N}{\begin{aligned}[t]
      &\app{\op{scope}}{(\lam{k}{\dexists x.\ \ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dand \ap{k}{x}})}{(\lam{x}{ \\
      &\etaE{(\ap{\trace}{x})}})}
    \end{aligned}}} \\
  \\
  \trace &: \iota \to \FF_{E'}(\iota) \\
  \trace &= \lam{x}{\app{\op{push}}{x}{(\lam{\_}{\etaE{x}})}}
\end{align*}

We split the computations into two layers: an outer layer using the
$\op{scope}$ effect, where the order will determine the relative scope of
quantifiers (using the $\op{fresh}$ effect in the $\dexists$ and $\dforall$
quantifiers), and an inner layer using all the other effects in $E'$, where
the order will determine the behavior of other phenomena such as anaphora
(e.g.,\ the $\op{push}$ of the QNP's trace and the $\op{get}$ of an
anaphoric pronoun). This way, we can have a different order of evaluation
in the two layers and get inverse scope readings without risking the
violation of crossover constraints.

We could have introduced two layers of computation into all of our NP
meanings but this would needlessly create complexity. Instead, only the
meanings of quantified noun phrases (abstract type $QNP$) will have two
layers. We can then plug these meanings into our grammars using one of
these two lexical items:

\begin{align*}
  \abs{in-situ} &: QNP \limp NP \\
  \lex{in-situ}{\lam{Q}{Q \hsbind (\lam{X}{X})}} \\
  \abs{QR} &: QNP \limp (NP \limp S) \limp S \\
  \lex{QR}{\lam{Q K}{Q \hsbind K}}
\end{align*}

$\abs{in-situ}$ collapses the two layers of effects so that quantified noun
phrases become single-layer computations, just like other NPs. With this
lexical item, we recover the original readings that were possible with the
single-layer denotations of every $\abs{every}$ and $\abs{a'}$ that we had
at the beginning of this section.

Furthermore, we can use $\abs{QR}$ to generate inverse scope (and all the
other permutations of quantifiers
from~\ref{ssec:quantifier-ambiguity}). $\abs{QR}$ evaluates the outer layer
of effects before the matrix clause, allowing it to take scope. The
computation in the inner layer, which is responsible for adding the
quantified variable into the context and making it anaphorically
accessible, takes the place of the QNP's trace.

Using $\abs{QR}$, we can explain the inverse scope reading of
Example~\ref{ex:inverse}.

\begin{exe}
  \ex A woman loves every man. \label{ex:inverse}
\end{exe}

\begin{align*}
  &\ap{(\cherry \circ \TOP\footnotemark)}{\sem{\app{\abs{QR}}{(\ap{\abs{every}}{\abs{man}})}{(\lam{O}{\app{\abs{loves}}{O}{(\ap{\abs{a'}}{\abs{woman}})}})}}} \\
  &\tto \forall y.\, \ap{\obj{man}}{y} \to (\exists x.\, \ap{\obj{woman}}{x} \land \app{\obj{love}}{x}{y})
\end{align*}

\footnotetext{After adding deixis, the type of $\TOP$ became
  $\iota \to \FF_E(1) \to \FF_\emptyset(o)$. However, we will often look at
  sentences which are not indexical. In such cases, we will overload $\TOP$
  to also mean ``the $\TOP$ handler without the $\withSpeaker$ handler'',
  type $\FF_{E \setminus \{\op{speaker}\}}(1) \to \FF_\emptyset(o)$. This
  means will not be obliged to provide a referent for the speaker.}

However, we cannot use the same mechanism to derive the incorrect reading
of Example~\ref{ex:crossover}.

\begin{align*}
  &\ap{(\cherry \circ \TOP \circ \banana{\onto{\op{get}}{(\lam{\_ k}{\ap{k}{e}})}})}{\sem{\app{\abs{QR}}{(\ap{\abs{every}}{\abs{man}})}{(\lam{O}{\app{\abs{loves}}{O}{(\ap{\abs{mother}}{\abs{he}})}})}}} \\
  &\tto \exists x.\, \app{\obj{mother}}{x}{(\ap{\selhe}{e})} \land (\forall y.\, \ap{\obj{man}}{y} \to \app{\obj{love}}{x}{y})\footnotemark
\end{align*}
\footnotetext{Note that the quantifier ranging over mothers has wider scope
  than the one ranging over men, even though we raised the QNP \emph{every
    man} over the whole sentence. This is because the referring expression
  \emph{his mother} is presuppositional and is accommodated globally, above
  the meaning of this particular sentence. The context in which the
  operator $\selhe$ looks for an antecedent to the pronoun \emph{his} is
  the context $(\ap{\obj{man}}{y}) \cons e$, where $e$ is the context in
  which the sentence is being evaluated. Since adding a proposition to a
  context is not supposed to change the set of possible antecedents, we
  write simply $\ap{\selhe}{e}$.}

We now have a grammar that is both capable of licensing inverse scope and
respects (certain) crossover constraints.\footnote{We will see shortly that
  there are situations for which our treatment is not sufficient.} The rest
of the grammar needs to be modified only insofar as handlers for
$\op{introduce}$ need to be replaced with handlers for $\op{fresh}$ and
$\op{push}$. The only other handler for $\op{introduce}$ besides $\BOX$ is
the $\asImplicature$ handler.

\begin{align*}
  \asImplicature &: \FF_{E \uplus \{\op{assert},\op{fresh},\op{push}\}}(\alpha) \to
                    \FF_{E \uplus \{\op{implicate},\op{fresh^i},\op{push^i}\}}(\alpha) \\
  \asImplicature &= \banana{\onto{\op{assert}}{\op{implicate}},\
                            \onto{\op{fresh}}{\op{fresh^i}},\
                            \onto{\op{push}}{\op{push^i}}}
\end{align*}

Since we no longer use $\op{introduce}$ as a primitive operation,
$\asImplicature$ will act on $\op{fresh}$ and $\op{push}$, turning them
into new operations, $\typedop{fresh^i}{1}{\iota}$ and
$\typedop{push^i}{\iota}{1}$. The converse handler, $\withImplicatures$,
will therefore also need to be changed to treat $\op{fresh^i}$ and
$\op{push^i}$.

\begin{align*}
  \withImplicatures &: \FF_{E \uplus E_\DRT \uplus \{\op{implicate},\op{fresh^i},\op{push^i}\}}(\alpha) \to
                       \FF_{E \uplus E_\DRT \uplus \{\op{assert},\op{fresh},\op{push}\}}(\alpha) \\
  \withImplicatures &= \banana{\onto{\op{implicate}}{\op{assert}},\
                               \onto{\op{fresh^i}}{\op{fresh}},\
                               \onto{\op{push^i}}{\op{push}}}
\end{align*}


\subsubsection{Connections to Other Solutions}

We will draw parallels to two other approaches.

In the interpretations of $\abs{every}$ and $\abs{a'}$, we introduce an
extra layer of computation. Then, instead of generalizing all other noun
phrases to employ this extra layer, we added $\abs{in-situ}$ and $\abs{qr}$
as lexical items into our grammar, allowing us to use quantified noun
phrases, which use this extra layer of computation, in contexts where an
ordinary noun phrase was expected. The interpretation of $\abs{qr}$ is the
$\hsbind$ operator. This is reminiscent of the way of composing different
monads proposed by Simon Charlow during Barker's and Bumford's ESSLLI 2015
course~\cite{barker2015monads}. The idea is that we should not try to build
some large monad that encompasses all aspects of meaning but rather build
meanings in smaller, different monads, each meaning using only as much
structure as it needs. The gluing together of the meanings is then
performed by the parser which can insert $\hsbind$ for the relevant monads
and other plumbing as necessary. This is also the kind of approach adopted
by Giorgolo and Asudeh~\cite{giorgolo2015natural}.

We also notice a similarity between our approach to inverse scope and that
of Shan in~\cite{shan2007inverse}. Shan adopts multistage programming to
suspend the evaluation of the context of the object until after the object
itself has been evaluated, effectively displacing the evaluation of the
object before the evaluation of the rest of the sentence. Our strategy is
based on similar techniques: $\abs{QR}$ has the same effect of displacing
evaluation and the denotations of $\abs{every}$ and $\abs{a'}$ suspend the
evaluation of their anaphoric effects. A distinguishing sign of
meta-programming or multistage programming are types like
$\FF_{E_1}(\FF_{E_2}(\alpha))$, i.e.\ programs producing programs, which is
exactly the kind of type we use for $\sem{QNP}$.


\subsubsection{Limitations}

Our treatment of inverse scope eliminates both primary crossover (the
raised quantifier is the object, e.g.\ Example~\ref{ex:primary-crossover})
and secondary crossover (the raised quantifier is embedded in the object,
e.g.\ Example~\ref{ex:secondary-crossover}). Examples
from~\cite{shan2006explaining}:

\begin{exe}
  \ex[*]{He$_1$ likes every man$_1$. \label{ex:primary-crossover}}
  \ex[*]{He$_1$ likes every man$_1$'s mother. \label{ex:secondary-crossover}}
\end{exe}

However, there is a configuration that we can construct in our grammar in
which a kind of crossover is permitted.

\begin{exe}
  \ex[*]{It$_1$ loves every owner of a dog$_1$. \label{ex:bad-crossover}}
\end{exe}

If we aim for the reading where there is a dog and it loves every one of
its owners (i.e.\ we raise the QNP \emph{a dog}), then everything works
correctly: we predict that the binding is impossible. However, if we raise
the whole object QNP \emph{every owner of a dog} to get the reading in
which there are possibly multiple different dogs, then we will license the
cataphoric binding from \emph{a dog} to \emph{it}. Even though the raising
of the object will not make the dog-owner available as an antecedent to the
subject, we will still have evaluated the object QNP's restrictor
\emph{owner of a dog}, which has the effect of introducing a new discourse
referent, a dog. If we were to outlaw cases like these, we would need a
more robust way of delaying the introduction of discourse referents.


\section{Considering Restrictive Relative Clauses}
\label{sec:relative-clauses}

There is one construction that we have not treated in our grammar and those
are restrictive relative clauses. We will sketch out possible ways of
dealing with those along with some of the challenges.

$$
\abs{who}_{\abs{r}} : (NP \limp S) \limp N \limp N
$$

Contrary to supplementary (appositive) relative clauses, which attach to
noun phrases and add extra information about their referent, restrictive
relative clauses attach to nouns and narrow down the set of individuals
under consideration, just like subsective adjectives (e.g.\ \emph{woman},
and \emph{woman who loves books} as \emph{book-loving woman}).

Restrictive relative clauses let us use the extension of any verb phrase as
the extension of a noun: for a given verb phrase $P$, we can form the noun
\emph{one who $P$s}. We therefore have an injection from verb phrases to
nouns, telling us verb phrases are nouns too. The question now is whether
the type of interpretations we use for nouns is large enough to fit the
denotations of verb phrases.

\begin{align*}
  \sem{NP \limp S} = \sem{NP} \limp \sem{S} &= \FF_E(\iota) \to \FF_E(1) \\
  \sem{N} &= \FF_E(\iota \to o)
\end{align*}

There are two important issues here. Firstly, the denotations of our
sentences are computations that express their truth conditions using side
effects. On the other hand, the denotations of our nouns are taken to be
computations that produce predicates, pure functions from individuals to
propositions. Secondly, the effects in the denotations $\sem{NP \limp S}$
can depend on the individual in $\sem{NP} = \FF_E(\iota)$ whereas the
effects in the denotations $\FF_E(\iota \to o)$ must be independent of the
argument individual.

The latter will lead us to trouble if we try fixing the former too naively:

\begin{align*}
  \sem{\abs{who}_{\abs{r}}} = \lam{K N}{\ap{\CC}{(\lam{x}{
    &N \hsbind (\lam{n}{ \\
    &\ap{K}{(\etaE{x})} \hsbind (\lam{\_}{ \\
    &\etaE{(\ap{n}{x})}})})})}}
\end{align*}

Here we add the truth conditions of the relative clause to the noun by
including the side effects of the clause in the effects of the
noun. However, this only works when the effects of the relative clause are
independent of the entity $x$ under consideration,\footnote{Because our use
  of $\CC$.} which is rarely the case. For example, assuming that
$\sem{\lam{x}{\app{\abs{loves}}{\abs{Mary}}{x}}} =
\lam{x}{\ap{\op{assert}!}{(\app{\obj{love}}{x}{\obj{m}})}}$, the meaning of
\emph{man who loves Mary} becomes:

\begin{align*}
& \sem{\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{loves}}{\abs{Mary}}{x}})}{\abs{man}}} \\
& \tto \ap{\CC}{(\lam{x}{\app{\op{assert}}{(\app{\obj{love}}{x}{\obj{m}})}{(\lam{\_}{\etaE{(\ap{\obj{man}}{x})}})}})}
\end{align*}

The evaluation of $\CC$ is blocked because the operation
$\ap{\op{assert}}{(\app{\obj{love}}{x}{\obj{m}})}$ depends on $x$. The
truth conditions of \emph{$x$ $P$s}, where $P$ is a verb phrase, will
always depend on $x$ and so this approach will not work.

However, our system already has a well-defined way for turning dynamic
propositions into simple propositions, and that is the $\BOX$ handler.

\begin{align*}
  \sem{\abs{who}_{\abs{r}}} = \lam{K N}{\ap{\CC}{(\lam{x}{
    &N \hsbind (\lam{n}{ \\
    &\ap{\BOX}{(\ap{K}{(\etaE{x})})} \hsbind (\lam{p}{ \\
    &\etaE{(\ap{n}{x} \land p)}})})})}} \\
  \sem{\abs{who}_{\abs{r}}} = \lam{K N}{\ap{\CC}{(\lam{x}{
    &(N \apl x) \andlr \ap{\BOX}{(\ap{K}{(\etaE{x})})}})}}
\end{align*}

By wrapping the meaning of the relative clause in a $\BOX$, its truth
conditions ($\op{assert}$ and $\op{introduce}$) are contained within the
noun's predicate and they do not block the $\CC$ operator. However, adding
the $\BOX$ in the entry for $\abs{who}_{\abs{r}}$ does have its
repercussions.\footnote{We have seen that the $\BOX$ handler corresponds to
  the boundary of a DRS.\@ We note that DRT does not instruct us to wrap
  the relative clause in a DRS and we can therefore expect our theory to
  diverge w.r.t.\ accessibility.} It will lead to the blocking of anaphoric
binding from the noun, as in the Example~\ref{ex:donkey-rc}.

\begin{exe}
  \exr{ex:donkey-rc} Every farmer who owns a donkey$_1$ beats it$_1$.
\end{exe}

Our entry for $\sem{\abs{who}_{\abs{r}}}$ gives the following meaning to
the noun \emph{farmer who owns a donkey}:

\begin{align*}
& \sem{\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{owns}}{(\ap{\abs{a}}{\abs{donkey}})}{x}})}{\abs{farmer}}} \\
& \tto \etaE{(\lam{x}{\ap{\obj{man}}{x} \land (\exists y.\, \ap{\obj{donkey}}{y} \land \app{\obj{own}}{x}{y})})}
\end{align*}

The result is a pure computation that is not going to introduce any
referents into the discourse (because all of the $\op{introduce}$
operations were captured by $\BOX$) and therefore it is not going to be
able to license the anaphoric binding to the pronoun \emph{it} in
Example~\ref{ex:donkey-rc}.

We have seen that by not using $\BOX$ evaluation gets stuck because the
$\op{assert}$ operations that carry the truth conditions of the relative
clause are not independent of the argument to which the noun's extension is
applied. On the other hand, by using $\BOX$, the $\op{introduce}$
operations that introduce new discourse referents are blocked and cannot
license the kind of anaphora that we see in Example~\ref{ex:donkey-rc}. We
can find the middle ground between the two by only handling $\op{assert}$
to get the truth conditions and letting $\op{introduce}$ project outside of
the noun.

\begin{align*}
  \withAssertions &: \FF_{E \uplus \{\op{assert}\}}(1) \to \FF_E(o) \\
  \withAssertions &= \lban \begin{aligned}[t]
      &\onto{\op{assert}}{(\lam{p k}{p \andr \ap{k}{\star}})}, \\
      &\onto{\eta}{(\lam{\_}{\top})} \, \rban
    \end{aligned} \\
  \sem{\abs{who}_{\abs{r}}} &= \lam{K N}{\ap{\CC}{(\lam{x}{(N \apl x) \andlr \ap{\withAssertions}{(\ap{K}{(\etaE{x})})}})}}
\end{align*}

Now, if we reexamine the meaning of the noun \emph{farmer who owns a
  donkey} under the new interpretation of $\abs{who}_{\abs{r}}$, we find
that the new discourse referent projects outside of the noun and will
therefore be able to bind the pronoun in Example~\ref{ex:donkey-rc}:

\begin{align*}
& \sem{\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{owns}}{(\ap{\abs{a}}{\abs{donkey}})}{x}})}{\abs{farmer}}} \\
& \tto \begin{aligned}[t]
    &\app{\op{introduce}}{\star}{(\lam{y}{ \\
    &\etaE{(\lam{x}{\ap{\obj{man}}{x} \land \ap{\obj{donkey}}{y} \land \app{\obj{own}}{x}{y}})}})}\end{aligned}
\end{align*}

In the rest of this section, we will discuss two topics related to
restrictive relative clauses. First, we will outline an analysis which
chooses a richer type of interpretations for nouns so that the lexical
entry for the relative pronoun will be less ad-hoc. Then, we will discuss how
relative clauses and other kinds of complex nouns interact with
presuppositions and definite descriptions.


\subsection{Different Interpretation for Nouns}
\label{ssec:different-nouns}

At the start of this section, we have shown the challenge that is posed by
folding in the meanings of sentences into the meanings of nouns when the
two are interpreted completely differently:

\begin{align*}
  \sem{NP \limp S} &= \FF_E(\iota) \to \FF_E(1) \\
  \sem{N} &= \FF_E(\iota \to o)
\end{align*}

If we change the type of interpretations of nouns so that truth conditions
are expressed as side effects and the effects can depend on the individual
argument, then there is no conflict any more and the lexical entry for
$\abs{who}_{\abs{r}}$ becomes trivial:

\begin{align*}
  \sem{NP \limp S} &= \FF_E(\iota) \to \FF_E(1) \\
  \sem{N} &= \iota \to \FF_E(1) \\
  \\
  \sem{\abs{who}_{\abs{r}}} &= \lam{k n x}{\ap{n}{x} \dand \ap{k}{(\etaE{x})}}
\end{align*}

The schema underlying the use of computation types in such a grammar could
be expressed the following way. Let the type of extensions
$\sem{A}_\petitv$ of an atomic abstract type $A$ be of the form
$a_1 \to \cdots \to a_n \to b$, where $a_i$ are atomic object types. Then
we will use the type $a_1 \to \cdots \to a_n \to \FF_E(b)$ as the
interpretation $\sem{A}_\petitc$ of the atomic abstract type $A$. This
means that the interpretations are call-by-value functions, taking $n$
values as arguments and then producing a computation.

\begin{align*}
  \sem{S}_\petitc &= \FF_E(o) \\
  \sem{NP}_\petitc &= \FF_E(\iota) \\
  \sem{N}_\petitc &= \iota \to \FF_E(o)
\end{align*}

Then, if we adopt the use of side effects to encode truth conditions, as in
our dynamic grammar, we get the following:

\begin{align*}
  \sem{S} &= \FF_E(1) \\
  \sem{NP} &= \FF_E(\iota) \\
  \sem{N} &= \iota \to \FF_E(1)
\end{align*}

If we were to adopt this schema universally, we could also adapt the
lifting operators and prove their conservativity by slightly modifying the
proof of Observation~\ref{obs:conservativity-lifting}.

\begin{align*}
  \liftl_\alpha &: \sem{\alpha}_\petitv \to \sem{\alpha}_\petitc \\
  \liftl_{S}(p) &= \etaE{p} \\
  \liftl_{NP}(x) &= \etaE{x} \\
  \liftl_{N}(n) &= \lam{x}{\etaE{(\ap{n}{x})}} \\
  \liftl_{S \limp \beta}(f) &= \lam{P}{P \hsbind (\lam{p}{\liftl_\beta(\ap{f}{p})})} \\
  \liftl_{NP \limp \beta}(f) &= \lam{X}{X \hsbind (\lam{x}{\liftl_\beta(\ap{f}{x})})} \\
  \liftl_{N \limp \beta}(f) &= \lam{N}{(\ap{\CC}{N}) \hsbind (\lam{n}{\liftl_\beta(\ap{f}{n})})}
\end{align*}

Finally, we could integrate this type of noun interpretations and the
simpler lexical entry for the relative pronoun by adjusting the grammar
that we have been building during this chapter.

\centerline{
\begin{minipage}{\linewidth}
\begin{align*}
  \lex{man}{\lam{x}{\ap{\op{assert}!}{(\ap{\obj{man}}{x})}}}
& \lex{man}{\etaE{\obj{man}}} \\
  \lex{woman}{\lam{x}{\ap{\op{assert}!}{(\ap{\obj{woman}}{x})}}}
& \lex{woman}{\etaE{\obj{woman}}} \\
& \vdots & & \vdots \\
  \lex{a}{\lam{N}{\app{\op{introduce}}{\star}{N}}}
& \lex{a}{\begin{aligned}[t]
     \lam{N}{&\app{\op{introduce}}{\star}{(\lam{x}{ \\
             &N \hsbind (\lam {n}{ \\
             &\app{\op{assert}}{(\ap{n}{x})}{(\lam{\_}{ \\
             &\etaE{x}})}})})}}
  \end{aligned}} \\
  \lex{every}{\lam{N}{\ap{\op{scope}}{\begin{aligned}[t]
      &(\lam{k}{\dforall x.\,\ap{\SI}{(\ap{N}{x})} \dimp \ap{k}{x}}) \\
      &(\lam{x}{\etaE{(\ap{\trace}{x})}})
    \end{aligned}}}}
& \lex{every}{\lam{N}{\ap{\op{scope}}{\begin{aligned}[t]
      &(\lam{k}{\dforall x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dimp \ap{k}{x}}) \\
      &(\lam{x}{\etaE{(\ap{\trace}{x})}})
    \end{aligned}}}} \\
  \lex{a'}{\lam{N}{\ap{\op{scope}}{\begin{aligned}[t]
      &(\lam{k}{\dexists x.\,\ap{\SI}{(\ap{N}{x})} \dand \ap{k}{x}}) \\
      &(\lam{x}{\etaE{(\ap{\trace}{x})}})
    \end{aligned}}}}
& \lex{a'}{\lam{N}{\ap{\op{scope}}{\begin{aligned}[t]
      &(\lam{k}{\dexists x.\,\ap{\SI}{((N \apl x) \hsbind \op{assert}!)} \dand \ap{k}{x}}) \\
      &(\lam{x}{\etaE{(\ap{\trace}{x})}})
    \end{aligned}}}} \\
  \lex{owner-of}{\lam{Y x}{(\ap{\obj{own}}{x} \apr Y) \hsbind \op{assert}!}}
& \lex{owner-of}{\lam{Y}{Y \hsbind (\lam{y}{\etaE{(\lam{x}{\app{\obj{own}}{x}{y}})}})}}
\end{align*}
\end{minipage}
}
\vspace{5mm}

These are all the changes that need to be made to the grammar,
\emph{except} for the entries having to do with presuppositions
($\abs{poss}$ and $\abs{the}$), which we will deal with next.


\subsection{Relative Clauses and Presuppositions}
\label{ssec:relative-clauses-presuppositions}

While changing the semantics of nouns and introducing restrictive relative
clauses, we have so far ignored their interaction with presupposition
triggers that depend on them. We will now give the semantics to these
referring expressions, observe some of their deficiencies and propose
solutions.\footnote{Below, we use the interpretation of nouns introduced
  in~\ref{ssec:different-nouns}. However, we could draw similar conclusions
  for the interpretation of nouns used in the rest of this chapter.}

\begin{align*}
  \lex{poss}{\lam{X N}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\CC}{(\BOX \circ N)} \hsbind (\lam{n}{ \\
      &\ap{\op{presuppose}!}{(\lam{y}{\ap{n}{y} \land \app{\obj{own}}{x}{y}})}})})
    \end{aligned}}} \\
  \lex{the}{\lam{N}{\begin{aligned}[t]
      &\ap{\CC}{(\BOX \circ N)} \hsbind (\lam{n}{ \\
      &\ap{\op{presuppose}!}{n}})
    \end{aligned}}}
\end{align*}

The $\op{presuppose}$ operation accepts \emph{static properties}, functions
of type $\iota \to o$, as arguments. Our noun is a \emph{dynamic
  property}\footnote{Terminology due to~\cite{lebedeva2012expression}.}, a
function of type $\iota \to \FF_E(1)$. To go from dynamic to static, we can
use the $\BOX$ handler to cast the $\op{introduce}$ and $\op{assert}$
operations down to propositions. Note that the same strategy is employed by
Lebedeva in~\cite{lebedeva2012expression} (Equations~(5.14) and~(5.22)):

\begin{align*}
  \widetilde{\sel} &= \lam{\textbf{P} e}{\app{\sel}{(\lam{x}{\appp{\textbf{P}}{(\lam{e}{x})}{e}{(\lam{e}{\top})}})}{e}} \\
  \widetilde{\sem{the}} &= \lam{\textbf{N} \textbf{P}}{\ap{\textbf{P}}{(\ap{\widetilde{\sel}}{\textbf{N}})}}
\end{align*}

The entry for the definite article uses the operator $\sel$, on which our
$\find$ operator is based. The $\sel$ operator is made compatible with
dynamic properties in $\widetilde{\textsf{sel}}$. This is done by applying
a context $e$ and the trivial continuation $\lam{e}{\top}$ to the dynamic
proposition $\ap{\textbf{P}}{(\lam{e}{x})}$.\footnote{This is equivalent to
  the use of the $\BOX$ handler in our approach.}

However, this solution can be lacking when the dynamic property which is
the denotation of the noun introduces new discourse referents itself (e.g.\
\emph{the man who owns a dog}).

\begin{align*}
& \sem{\ap{\abs{the}}{(\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})}{x}})}{\abs{man}})}} \\
& \tto \ap{\op{presuppose}!}{(\lam{x}{\exists y.\, \ap{\obj{man}}{x} \land
  \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y}})}
\end{align*}

If we were to accommodate such a presupposition, we would introduce at the
global level a new discourse referent satisfying the above
condition. However, the binding potential of the NP \emph{a dog} would have
already been wasted by the use of $\BOX$ (or in the case of TTDL, the use
of $\lam{e}{\top}$). This means that we would not be able to account for
the binding in Example~\ref{ex:presupposition-binding}.

\begin{exe}
  \ex The man who owns a dog$_1$ loves it$_1$. \label{ex:presupposition-binding}
\end{exe}

Before we address this issue, we turn to another similar problem. We will
consider a very similar situation, but instead of introducing a discourse
referent, the relative clause will trigger a presupposition where the
description of the presupposed individual will contain a variable bound by
the relative clause. For example, in \emph{the man$_1$ who loves his$_1$
  dog}, the genitive construction \emph{his$_1$ dog} is a presupposition
trigger but the presupposition cannot project outside of the relative
clause because the variable $1$ has scope only over the relative clause. If
we were to calculate the meaning of \emph{the man$_1$ who loves his$_1$
  dog} in the TTDL of~\cite{lebedeva2012expression}, we would get the
following:

\begin{align*}
& \sem{\textit{the man$_1$ who loves his$_1$ dog}} \\
& = \lam{\textbf{P} e \phi}{\appp{\textbf{P}}{(\app{\textsf{sel}}{(\lam{x}{\ap{\textsf{raise}}{(\ap{\texttt{AbsentIndividualExc}}{(\lam{y}{\ap{\obj{dog}}{y} \land \app{\obj{poss}}{x}{y}})})}})}{e})}{e}{\phi}}
\end{align*}

At this point, we would get stuck since the exception cannot propagate
outside of the lambda abstraction $\lambda x$, because $x$ is bound within
the exception's message,
$\lam{y}{\ap{\obj{dog}}{y} \land \app{\obj{poss}}{x}{y}}$.\footnote{This
  kind of stuck term is very similar to the
  $\ap{\CC}{(\lam{x}{\app{\op{presuppose}}{(\lam{y}{\ap{\obj{dog}}{y} \land
          \app{\obj{poss}}{x}{y}})}{(\lam{y}{M_\petitc(y)})}})}$ in
  $\calc$.} However, in TTDL we can fix this by using the same intermediate
accommodation handler as is used in the dynamic existential quantifier to
solve the binding problem.\footnote{The $\textsf{iacc}$ handler that we
  mentioned in~\ref{ssec:comparison-ttdl}, defined
  in~\cite{lebedeva2012expression}, Definition~6.29.} In our approach, the
handler responsible for intermediate accommodation, $\maybeAccommodate$, is
already part of the $\BOX$ handler and so evaluation does not get stuck and
the presupposition is accommodated. Nevertheless, to get the intended
reading of the above noun phrase, we will have to make the argument to the
property anaphorically accessible within the noun:\footnote{In the
  presentation of TTDL in Lebedeva's thesis~\cite{lebedeva2012expression},
  adding the condition $\ap{\obj{man}}{x}$ to the context suffices to make
  $x$ accessible. In our setting, we make a distinction between adding a
  fact to the common ground using $\op{assert}$ versus introducing a new
  discourse referent for discussion using $\op{push}$ or $\op{introduce}$
  (this lets us give a (partial) account of crossover constraints).}

\begin{align*}
  \lex{the}{\lam{N}{\begin{aligned}[t]
      &\ap{\CC}{(\lam{x}{\ap{\BOX}{(\app{\op{push}}{x}{(\lam{\_}{\ap{N}{x}})})}})} \hsbind (\lam{n}{ \\
      &\ap{\op{presuppose}!}{n}})
    \end{aligned}}}
\end{align*}

We can now use this entry to compute the meaning of the noun phrase
\emph{the man$_1$ who loves his$_1$ dog}. When presenting the result, we
use the $\EMPTY$ and $\search$ handlers to filter out the irrelevant
branches (looking for the antecedent of \emph{his dog} in the context and
trying to project outside of the relative clause).

\begin{align*}
& \ap{\search}{(\ap{\EMPTY}{\sem{\ap{\abs{the}}{(\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{loves}}{(\app{\abs{poss}}{\abs{he}}{\abs{dog}})}{x}})}{\abs{man}})}}})} \\
& \tto \ap{\op{presuppose}!}{(\lam{x}{\exists y.\, \ap{\obj{dog}}{y} \land
  \app{\obj{own}}{x}{y} \land \ap{\obj{man}}{x} \land \app{\obj{love}}{x}{y}})}
\end{align*}

We have solved the problem of the definite description \emph{the $N$ who
  $P$s} where $P$ triggers a presupposition dependent on $N$. However,
there is still the same issue that we encountered at the beginning of this
subsection. When we accommodate the presupposition triggered by the
definite description \emph{the man who loves his dog}, we introduce the man
as a discourse referent. However, the scope of the quantifier ranging over
dogs will be limited to the proposition
$\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land
\ap{\obj{man}}{x} \land \app{\obj{love}}{x}{y}$. This means that we will
not be able to explain the anaphoric binding in
Example~\ref{ex:presupposition-binding2}.

\begin{exe}
  \ex The man$_1$ who loves his$_1$ dog$_2$ treats it$_2$ well. \label{ex:presupposition-binding2}
\end{exe}


\subsubsection{Sketching a Solution --- Dynamic Presuppositions}

If we want the dynamic effects of definite descriptions to have
discourse-wide scope, then we should move their whole evaluation, not just
their results, to the global context. We can change the type of
$\op{presuppose}$ so that we are not signalling the presupposition of
static properties but of dynamic ones.

$$
\typedop{presuppose}{(\iota \to \FF_{E^*}(1))}{\iota}
$$

However, we have to be careful about the effect signature $E^*$ used
above. From the discussion in Section~\ref{sec:adding-quantification}, we
know that $E^*$ cannot include
$\typedop{presuppose}{(\iota \to \FF_{E^*}(1))}{\iota}$ because then $E^*$
is not well-defined. For similar reasons, $E^*$ cannot contain
$\typedop{scope}{((\iota \to \FF_{E'}(1)) \to \FF_{E'}(1))}{\iota}$,
because $\op{presuppose} \in E'$.

We can dispose of the $\op{presuppose}$ effects by evaluating them and
accommodating them using $\op{introduce}$ and $\op{assert}$ should they
depend on the argument of the property (e.g.\ \emph{the man who is talking
  to Peter} should presuppose the existence of a salient individual called
Peter and \emph{the man$_1$ who is talking to his$_1$ friend} should, when
accommodated, introduce two individuals, a man and his friend).

The $\op{scope}$ effect can be eliminated either by evaluating it (i.e.\
projecting it) or by handling it with $\SI$. Handling it would give us
narrow scope w.r.t.\ the presupposition, whereas projecting it would give
us wider scope. We find that both are possible: narrow scope in
Example~\ref{ex:presupposition-every-narrow} and wide scope in
Example~\ref{ex:presupposition-every-wide}. We will therefore choose
narrow scope by default, since in that case we can always derive the wider
scope by quantifier raising with $\abs{QR}$.

\begin{exe}
  \ex The owner of every book ever published by Elsevier must be very
  rich. \label{ex:presupposition-every-narrow}
  \ex Mary sent an email to the representative of every
  country. \label{ex:presupposition-every-wide}
\end{exe}

Coming at it from a different angle, we can start looking at the effects
that we \emph{need} to have in $E^*$. Our dynamic properties need to convey
truth conditions ($\op{assert}$) and introduce discourse referents
($\op{introduce}$, or rather its parts: $\op{fresh}$ and $\op{push}$).

Next we look at what to do with the anaphoric operation $\op{get}$. If we
were not to evaluate the $\op{get}$ operation at the point where the
presupposition is triggered but rather project it as part of the
presupposed material and evaluate in the global context (or some other
accommodation site), then we would not be able to derive the reading of
Example~\ref{ex:every-presupposition}. If we were to evaluate \emph{$x$ is
  the sound of their voice} in the global context, we could no longer bind
the pronoun \emph{their} to its intended antecedent. On the other hand, we
cannot evaluate the $\op{get}$ operations without evaluating the
$\op{introduce}$ operations (which we do not want to do since we want to
evaluate them at accommodation-time) because otherwise we would break
anaphoric binding \emph{within} the dynamic proposition being
presupposed. For example, in Example~\ref{ex:binding-in-presupposition}, we
would need to evaluate the $\op{introduce}$ operation of the indefinite
\emph{a car} in order for the $\op{get}$ operation used by the pronoun to
be able to bind to the car.

\begin{exe}
  \ex Everyone$_1$ hates the sound of their$_1$
  voice. \label{ex:every-presupposition}
  \ex John met the woman who stole a car$_1$ by hacking into its$_1$
  computer. \label{ex:binding-in-presupposition}
\end{exe}

We can deal with this by preserving the $\op{get}$ operations in the
material being presupposed (so that internal anaphoric binding will work
correctly) but making sure that they have access to all the referents
available at the point of triggering the presupposition. For this kind of
manipulation, we introduce the $\inTheContext$ handler, which for any
context $e$ and computation $X$ will yield the computation
$\app{\inTheContext}{e}{X}$ that, when evaluated, will have access to the
material in the context $e$.

\begin{align*}
  \inTheContext &: \gamma \to \FF_{E \uplus \{\op{get}\}}(\alpha)
                          \to \FF_{E \uplus \{\op{get}\}}(\alpha) \\
  \inTheContext &= \lam{e}{\banana{\onto{\op{get}}{(\lam{\_ k}{\app{\op{get}}{\star}{(\lam{e'}{\ap{k}{(e \cat e')}})}})}}}
\end{align*}

Finally, we have the rest of the effects, such as $\op{speaker}$ and
$\op{implicate}$. We could either evaluate them at the point where the
presupposition is triggered or include them into the set of effects $E^*$
that is projected with the presupposition. Note that if we include them in
$E^*$, then they might get evaluated twice: once when the argument to
$\op{presuppose}$ is evaluated down to a static property to be used with
$\selP$ to search for an existing referent satisfying the definite
description, and then, if the referent does not exist, a second time to
accommodate the presupposition and evaluate all of its dynamic effects in
the global context. If we include these effects into the dynamic property
that is given to $\op{presuppose}$ as an argument, then these should be
idempotent so that repeated evaluation does not interfere with the
semantics, or we should take special care of them when doing multiple
evaluations. Both $\op{speaker}$ and $\op{implicate}$ are idempotent, so we
are not limited by this factor. However, we still want to keep $E^*$ as
simple as possible and so we will evaluate these effects at the point where
the presupposition is triggered.

This means that the effect signature $E^*$ in
$\typedop{presuppose}{(\iota \to \FF_{E^*}(1))}{\iota}$ will be the
$E_\DRT$ effect signature from Chapter~\ref{chap:dynamic-semantics}, though
with $\op{introduce}$ replaced with $\op{fresh}$ and $\op{push}$ due to the
changes we have made in~\ref{ssec:crossover}.

\begin{align*}
  E^* = \{\ &\typedop{get}{1}{\gamma}, \\
            &\typedop{fresh}{1}{\iota}, \\
            &\typedop{push}{\iota}{1}, \\
            &\typedop{assert}{o}{1}\ \}
\end{align*}

Our intention is to handle or evaluate the effects of the noun in the
definite description with the exception of the effects in $E^*$. This means
that we want to split the computation of the noun's meaning into two
layers: one using the effects in $E \setminus E^*$ and another using the
effects in $E^*$. We can write a handler for this.\footnote{This amounts to
  reordering all of the operations in a computation so that the ones in
  $E \setminus E^*$ go before those in $E^*$. This is not always possible
  since some of the operations from $E \setminus E^*$ might depend on the
  results of some of the operations in $E^*$. We can therefore expect the
  handler to make use of $\CC$, our partial operator for messing around
  with evaluation and functional dependencies.}

\begin{align*}
  \separateDynamics &: \FF_{E \uplus E^*}(\alpha) \to \FF_E(\FF_{E^*}(\alpha)) \\
  \separateDynamics &= \lban \begin{aligned}[t]
      &\onto{\op{get}}{(\lam{x k}{\ap{\op{get}}{x} \apr (\ap{\CC}{k})})}, \\
      &\onto{\op{fresh}}{(\lam{x k}{\ap{\op{fresh}}{x} \apr (\ap{\CC}{k})})}, \\
      &\onto{\op{push}}{(\lam{x k}{\ap{\op{push}}{x} \apr (\ap{\CC}{k})})}, \\
      &\onto{\op{asssert}}{(\lam{x k}{\ap{\op{assert}}{x} \apr (\ap{\CC}{k})})}, \\
      &\onto{\eta}{(\lam{x}{\etaE{(\etaE{x})}})}\ \rban
    \end{aligned}
\end{align*}

We can now finally give an interpretation to the definite article
$\abs{the}$ as well as the other presupposition triggers.

\begin{align*}
  \packageProperty &: (\iota \to \FF_{E \uplus E^*}(1))
                  \to \FF_{E \uplus \{\op{get}\}}(\iota \to \FF_{E^*}(1)) \\
  \packageProperty &= \lam{P}{\begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\ap{\CC}{(\lam{x}{\ap{\separateDynamics}{(\app{\inTheContext}{e}{(\ap{\maybeAccommodate}{(\ap{\SI}{(\ap{P}{x})})})})}})}})}
    \end{aligned}}
\end{align*}

\begin{align*}
  \lex{the}{\lam{N}{\begin{aligned}[t]
      &\ap{\packageProperty}{(\lam{x}{\app{\op{push}}{x}{(\lam{\_}{\ap{N}{x}})}})} \hsbind (\lam{N'}{ \\
      &\ap{\op{presuppose}!}{N'}})
    \end{aligned}}} \\
  \lex{poss}{\lam{X N}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\packageProperty}{(\lam{y}{\app{\op{push}}{y}{(\lam{\_}{\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{\ap{N}{y}})}})}})} \hsbind (\lam{N'}{ \\
      &\ap{\op{presuppose}!}{N'}})})
    \end{aligned}}} \\
  \lex{children-of}{\lam{X}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\packageProperty}{(\lam{y}{\ap{\op{assert}!}{(\app{\obj{children}}{y}{x})}})} \hsbind (\lam{N'}{ \\
      &\ap{\op{presuppose}!}{N'}})})
    \end{aligned}}} \\
  \sem{\abs{children-of}} &\approx \lam{X}{\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\ap{\op{presuppose}!}{(\lam{y}{\ap{\op{assert}!}{(\app{\obj{children}}{y}{x})}})}})
    \end{aligned}}
\end{align*}

Finally, since we have changed the type (and therefore also the intended
semantics) of the $\op{presuppose}$ operation, we will also have to modify
its handlers ($\accommodate$, $\maybeAccommodate$ and $\useFind$)
accordingly.

\begin{align*}
  \accommodate &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to \FF_{E \uplus E^*}(\alpha) \\
  \accommodate &= \banana{\onto{\op{presuppose}}{(\lam{P k}{
    \app{\op{introduce}}{\star}{(\lam{x}{(\ap{P}{x}) \hsbind (\lam{\_}{\ap{k}{x}})})}})}} \\
  \maybeAccommodate &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to
                      \FF_{E \uplus E^* \uplus \{\op{presuppose},\op{amb}\}}(\alpha) \\
  \maybeAccommodate &= \banana{\onto{\op{presuppose}}{(\lam{P k}{
    \app{\op{presuppose}}{P}{k} +
    \app{\op{introduce}}{\star}{(\lam{x}{(\ap{P}{x}) \hsbind (\lam{\_}{\ap{k}{x}})})}})}} \\
  \useFind &: \FF_{E \uplus \{\op{presuppose}\}}(\alpha) \to \FF_{E \uplus \{\op{get}, \op{presuppose}\}}(\alpha) \\
  \useFind &= \banana{\onto{\op{presuppose}}{(\lam{P k}{\ap{\find}{P} \hsbind k})}} \\
  \\
  \find &: (\iota \to \FF_{E^*}(1)) \to \FF_{E \uplus \{\op{get}, \op{presuppose}\}}(\iota) \\
  \find &=
          \lam{P}{\app{\op{get}}{\star}{(\lam{e}{\case{\app{\selP}{(\cherry \circ \empty \circ \box \circ P)}{e}}{x}{\etaE{x}}{\_}{\ap{\op{presuppose}!}{P}}})}}
\end{align*}

In $\accommodate$ and $\maybeAccommodate$, instead of asserting
$\ap{P}{x}$, we evaluate it, letting it have its dynamic effects at
wherever the presupposition is being accomodated. The $\useFind$ handler
will work the same way as before but with a new definition for $\find$
which works on dynamic predicates of type $\iota \to \FF_{E^*}(1)$. $\find$
will map dynamic predicates to static predicates using
$\cherry \circ \empty \circ \BOX$. The use of $\empty \circ \BOX$ blocks
any dynamic effects in the predicate $P$.\footnote{And thanks to
  $\separateDynamics$, dynamic effects (those from $E^*$) are the only effects in
  $P$.} This can be intuitively understood as the listener considering
whether there exists some $x$ such that $\ap{P}{x}$ without committing the
(dynamic) effects of $P$ to the common ground.

With all of this heavy machinery in place, we now have a system that can
deal with sentences like Example~\ref{ex:presupposition-binding} and
Example~\ref{ex:presupposition-binding2}. The noun phrases \emph{the man
  who owns a dog} and \emph{the man who loves his dog} both trigger
presuppositions with dynamic content. This content is then accommodated
globally and all the new discourse referents are available in subsequent
discourse.

\begin{exe}
  \exr{ex:presupposition-binding} The man who owns a dog$_1$ loves
  it$_1$.
  \exr{ex:presupposition-binding2} The man$_1$ who loves his$_1$ dog$_2$
  treats it$_2$ well.
\end{exe}

\begin{align*}
& \sem{\ap{\abs{the}}{(\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})}{x}})}{\abs{man}})}} \\
& \leadsto \ap{\op{presuppose}!}{(\lam{x}{\begin{aligned}[t]
    &\app{\op{push}}{x}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\ap{\obj{man}}{x})}{(\lam{\_}{ \\
    &\app{\op{introduce}}{\star}{(\lam{y}{ \\
    &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}})}})})
  \end{aligned}}}
& & \approx \ap{\op{presuppose}!}{(\lam{x}{\begin{aligned}[t]
    &\app{\op{assert}}{(\ap{\obj{man}}{x})}{(\lam{\_}{ \\
    &\app{\op{introduce}}{\star}{(\lam{y}{ \\
    &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}})})
  \end{aligned}}} \\
  \\
& \sem{\ap{\abs{the}}{(\app{\abs{who}_{\abs{r}}}{(\lam{x}{\app{\abs{loves}}{(\app{\abs{poss}}{\abs{he}}{\abs{dog}})}{x}})}{\abs{man}})}} \\
& \leadsto \ap{\op{presuppose}!}{(\lam{x}{\begin{aligned}[t]
    &\app{\op{push}}{x}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\ap{\obj{man}}{x})}{(\lam{\_}{ \\
    &\app{\op{introduce}}{\star}{(\lam{y}{ \\
    &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
    &\app{\op{get}}{\star}{(\lam{e}{ \\
    &\app{\op{assert}}{(\app{\obj{own}}{(\ap{\selhe}{e})}{y})}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\app{\obj{love}}{x}{y})}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}})}})}})}})})
  \end{aligned}}}
& & \approx \ap{\op{presuppose}!}{(\lam{x}{\begin{aligned}[t]
    &\app{\op{assert}}{(\ap{\obj{man}}{x})}{(\lam{\_}{ \\
    &\app{\op{introduce}}{\star}{(\lam{y}{ \\
    &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
    &\app{\op{assert}}{(\app{\obj{love}}{x}{y})}{(\lam{\_}{ \\
    &\etaE{\star}})}})}})}})}})})
  \end{aligned}}}
\end{align*} 

We also derive the intended readings behind
Examples~\ref{ex:presupposition-every-narrow},
\ref{ex:presupposition-every-wide}, \ref{ex:every-presupposition}
and~\ref{ex:binding-in-presupposition}, but that was already the case
before delving into dynamic presuppositions.


\section{Summary}
\label{sec:composing-summary}

In this chapter, we have built up a single grammar that covered anaphora,
presuppositions (of referring expressions), deixis (of first person
pronouns), quantifiers and conventional implicatures (of appositive
clauses). The grammar can derive the meanings of all the sentences we
analyzed in Chapters~\ref{chap:introducing-effects}
and~\ref{chap:dynamic-semantics} using the same abstract syntactic
structure.\footnote{With the exception of in-situ quantifiers which now use
  the $\abs{in-situ}$ operator.} Furthermore, the grammar covers sentences
which combine these phenomena, such as Example~\ref{ex:combo}.\footnote{For
  the detailed process of computing the meaning of Example~\ref{ex:combo},
  take a look in Appendix~\ref{chap:final-example}.}

\begin{exe}
  \ex My best friend, who owns a dog$_1$, said it$_1$ loves
  everyone. \label{ex:combo}
\end{exe}

\vspace*{-5mm}

\begin{align*}
& \sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}} \\
& \tto \begin{aligned}[t]
      &\app{\op{speaker}}{\star}{(\lam{s}{ \\
      &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
      &\app{\op{introduce^i}}{\star}{(\lam{y}{ \\
      &\app{\op{implicate}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{implicate}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}})}})}})}})}
    \end{aligned} \\
  \\
& \ap{\cherry}{(\app{\TOP}{s}{\sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}}})} \\
& \tto \exists x.\, \app{\obj{best-friend}}{x}{s} \land (\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land \app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{y}{z})})
\end{align*}


\subsection{Note on Conservativity}
\label{ssec:conservativity}

An interesting feature of the grammar is that as we added more and more
phenomena throughout Sections~\ref{sec:adding-presuppositions},
\ref{sec:adding-conventional-implicature}, \ref{sec:adding-deixis} and
\ref{sec:adding-quantification}, we rarely modified the interpretations of
existing entries. For example, we did not need to turn our interpretations
of proper nouns or pronouns into generalized quantifiers when adding
quantification, we did not need to change the interpretation of transitive
verbs to account for the fact that both subject and object might carry
conventional implicatures, etc.

The changes that we did to existing interpretations consisted almost
exclusively of inserting handlers for new effects which did not exist in
the grammar before. For example, in
Section~\ref{sec:adding-presuppositions}, we added the $\useFind$ and
$\maybeAccommodate$ handlers for the new $\op{presuppose}$ operation into
the $\BOX$ combinator and in Section~\ref{sec:adding-quantification}, we
added the $\SI$ handler for the new $\op{scope}$ operation to the
interpretations of tensed verbs. In all those four sections, we also
modified the $\TOP$ combinator by composing it with a handler for the newly
defined effect. However, we know that if we apply a handler to a
computation in which none of the operations being handled occur, then the
result will be the same computation (modulo stuck computations). Therefore,
we have a strong conservativity result for our incremental grammar. In the
grammars developed from Sections~\ref{sec:dynamic-kernel}
to~\ref{sec:adding-quantification} (Subsection~\ref{ssec:crossover} not
included), if an abstract term has an interpretation in one grammar, then
it has the same interpretation in every other grammar in which it is
derivable (i.e.\ in every one of its extensions). This is because any
extension would only change the interpretation by inserting handlers for
effects which are not used in the interpretation and therefore the handlers
would make no difference.
