\chapter{Properties}
\label{chap:properties}


\section{Algebraic Properties}
\label{sec:algebraic-properties}


\section{Subject Reduction}


\section{Confluence}

The object of our study during this section will be the proof of the
\emph{confluence property} of $\banana{\lambda}$.

\begin{definition}
  A reduction relution $\to$ on a set $A$ is said to be \demph{confluent}
  whenever for each $a,b,c \in A$ such that $a \to b$ and $a \to c$ there
  is a $d \in A$ such that $b \tto d$ and $c \tto d$.
\end{definition}

\begin{theorem}\label{thm:confluence}
  \demph{Confluence of $\banana{\lambda}$}
  
  The reduction relation $\to$, defined by the reduction rules
  in~\ref{sec:reductions}, on the set of $\banana{\lambda}$ terms is
  confluent.
\end{theorem}

Proofs of this property are often mechanical and follow the same
pattern. Our strategy will be to reuse a general result which applies one
such proof for a general class of rewriting systems. Our rewriting system
is a system of reductions on terms and the reductions have side conditions
concerning the binding of free variables. A good fit for this kind of
system are the Combinatory Reduction Systems (CRSs) of
Klop~\cite{klop1993combinatory}.

The main result about CRSs that we will make use of is the following
(Corollary~13.6 in~\cite{klop1993combinatory}).

\begin{theorem}\label{thm:confluence-crs}
  \demph{Confluence of orthogonal CRSs}

  All orthogonal CRSs are confluent.
\end{theorem}

The rest of this section will go like this:
\begin{itemize}
\item First, we define Combinatory Reduction Systems.
\item Next, we show that our reduction relation can be coded as a CRS.
\item Afterwards, we explain the orthogonality condition.
\item Finally, we verify whether orthogonality holds for our CRS.
\end{itemize}


\subsection{Combinatory Reduction Systems}
\label{ssec:crs}

A Combinatory Reduction System is defined by an alphabet and a set of
rewriting rules. We will first cover the alphabet.

\begin{definition}
  A \demph{CRS alphabet} consists of:
  \begin{itemize}
  \item a set $\Var$ of \emph{variables} (written lower-case as $x$, $y$,
    $z$,\ldots)
  \item a set $\MVar$ of \emph{metavariables} (written upper-case as $M$,
    $N$, \ldots), each with is own arity
  \item a set of \emph{function symbols}, each with its own arity
  \end{itemize}
\end{definition}

Let us sketch the difference between the variables in $\Var$ and the
metavariables in $\MVar$. The variables in $\Var$ are the variables of the
object-level terms, in our case it will be the variables of
$\banana{\lambda}$. The variables in $\MVar$ are the metavariables that
will occur in our reduction rules and which we will have to instantiate in
order to derive specific application of those rules. In other words, the
variables in $\Var$ are there to express the binding structure within the
terms being reduced and the metavariables in $\MVar$ are there to stand in
for specific terms when applying a reduction rule.

\begin{definition}
  The \demph{metaterms} of a CRS are given inductively with:
  \begin{itemize}
  \item variables are metaterms
  \item if $t$ is a metaterm and $x$ a variable, then $[x]t$ is a metaterm
    called \emph{abstraction}
  \item if $F$ is an $n$-ary function symbol and $t_1$,\ldots,$t_n$ are
    metaterms, then $F(t_1,\ldots,t_n)$ is a metaterm
  \item if $M$ is an $n$-ary metavariable and $t_1$,\ldots,$t_n$ are
    metaterms, then $M(t_1,\ldots,t_n)$ is a metaterm
  \end{itemize}
\end{definition}

\begin{definition}
  The \demph{terms} of a CRS are its metaterms which do not contain any
  metavariables.
\end{definition}

To finish the formal introduction of CRSs, we give the definition of a CRS
reduction rule.

\begin{definition}
  A CRS \emph{reduction} (or \emph{rewrite}) rule is a pair of metaterms $s
  \to t$ such that:
  \begin{itemize}
  \item $s$ and $t$ are both closed, i.e.\ all variables are bound using
    the $[\_]\_$ binder
  \item $s$ is of the form $F(t_1,\ldots,t_n)$
  \item all the metavariables that occur in $t$ also occur in $s$
  \item any metavariable $M$ that occurs in $s$ only occurs in the form
    $M(x_1,\ldots,x_k)$, where $x_i$ are pairwise distinct variables
  \end{itemize}
\end{definition}

A CRS is then an alphabet coupled with a set of reduction rules. We will
only sketch the way that a CRS gives rise to a reduction relation and we
will direct curious readers to Sections~11 and 12 of
$\cite{klop1993combinatory}$.

When we instantiate the metavariables in a CRS rule, we use a
\emph{valuation} that assigns to every $n$-ary metavariable a term with
holes labelled from 1 to $n$. The instantiation of $M(t_1,\ldots,t_n)$ then
replaces the metavariable $M$ by the term with holes and fills the holes
labelled $1,\ldots,n$ with the terms $t_1,\ldots,t_n$ respectively.

The crucial detail is that in a particular context, a metavariable can only
be instantiated with terms $M$ that do not contain any free variables bound
in that context. This means that for the instantiation of $M$ to contain a
variable bound in the context, $M$ must explicitly take that variable as an
argument. All other variables not explicitly declared can therefore be
safely assumed to not occur freely within.

Consider the following examples of $\beta$ and $\eta$ reduction.

\begin{align*}
  \ap{(\lam{x}{M(x)})}{N} & \to M(N) \\
  \lam{x}{\ap{N}{x}} & \to N
\end{align*}

More formally written as:

\begin{align*}
  @(\lambda([x]M(x)),N) & \to M(N) \\
  \lambda([x]@(N,x)) & \to N
\end{align*}

where $\lambda$ is a unary function symbol and $@$ is a binary function
symbol. In both of the versions, $M$ is a unary metavariable and $N$ is a
nullary metavariable. In the rule for $\beta$-reduction, we can observe how
the idea of instantiating metavariables by terms with holes lets us express
the same idea for which we had to introduce the meta-level operation of
substitution. In the rule for $\eta$-reduction, we see that $N$ appears in
a context where $x$ is bound but it does not have $x$ as one of its
arguments. Therefore, it will be impossible to instantiate $N$ in such a
way that it contains a free occurrence of $x$. In both of those rules, we
were able to get rid of meta-level operations (substitution) and conditions
($x \notin FV(N)$) and have them both implemented by the formalism itself.


\subsection{$\banana{\lambda}$ as a CRS}
\label{ssec:banana-as-crs}

We will now see how to rephrase the reduction rules of our calculus in
order to fit in to the CRS framework. We have already seen how to translate
the $\beta.\to$ and $\eta.\to$ rules in the previous subsection. The next
rules to address are the rules defining the semantics of the $\banana{}$
handlers.

We will repeat the rules for handlers to make the issue at hand clear.

\begin{tabular}{lr}
  $\ap{\cibanana}{(\ap{\eta}{N})} \to$ & rule $\banana{\eta}$ \\
  $\ap{M_\eta}{N}$ & \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}_j}{N_{\mathrm{p}}}}{(\lam{x}{N_{\mathrm{c}}})})} \to$ & rule $\banana{\op{op}}$ \\
  $\ap{M_j}{\ap{N_{\mathrm{p}}}{(\lam{x}{\ap{\cibanana}{N_{\mathrm{c}}}})}}$
  & where $j \in I$ \\
  & and $x \notin \FV((M_i)_{i \in I}, M_\eta)$ \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}_j}{N_{\mathrm{p}}}}{(\lam{x}{N_{\mathrm{c}}})})} \to$ & rule $\banana{\op{op}'}$ \\
  $\ap{\op{op}_j}{\ap{N_{\mathrm{p}}}{(\lam{x}{\ap{\cibanana}{N_{\mathrm{c}}}})}}$
  & where $j \notin I$ \\
  & and $x \notin \FV((M_i)_{i \in I}, M_\eta)$
\end{tabular}

\TODO{Make sure later that the form of these rules in the Definitions
  chapter is the same as the one above.}

The syntax of CRSs does not allow us to use the $(\onto{\op{op}_i}{M_i})_{i
  \in I}$ notation nor capture the $j \in I$ or $j \notin I$ conditions.
The symbols $\op{op}_i$ are problematic as well, since technically, they
are not pure $\banana{\lambda}$ syntax but metavariables standing in for
operation symbols.

We do away with all of the above problems by expanding these meta-notations
and adding a separate rule for every possible instantiation of the
schema. This means that for each sequence of distinct operation symbols
$\op{op}_1$,\ldots,$\op{op}_n$, we end up with:
\begin{itemize}
\item a special rewriting rule
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\etaE{N})}
  \to \ap{M_\eta}{N}$
\item for every $1 \le i \le n$, a special rewriting rule \\
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\app{\op{op}_i}{N_{\mathrm{p}}}{(\lam{x}{N_{\mathrm{c}}(x)})})}
  \\ \to
  \app{M_i}{N_{\mathrm{p}}}{(\lam{x}{\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ \onto{\eta}{M_\eta}}}{N_{\mathrm{c}}(x)}})}$
\item for every $\op{op}' \in \EE \setminus \{\op{op}_i \| 1 \le i \le n\}$, a special
  rewriting rule \\
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\app{\op{op}'}{N_{\mathrm{p}}}{(\lam{x}{N_{\mathrm{c}}(x)})})}
  \\ \to
  \app{\op{op}'}{N_{\mathrm{p}}}{(\lam{x}{\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ \onto{\eta}{M_\eta}}}{N_{\mathrm{c}}(x)}})}$
\end{itemize}

The rule for the cherry $\cherry$ extraction operator is already in CRS
form, so all we have to do is address the rules for the $\CC$ operator. We
present them side-by-side in their original form and in CRS-style.

Original:
\begin{align*}
  \ap{\CC}{(\lam{x}{\ap{\eta}{M}})} & \to \ap{\eta}{(\lam{x}{M})} \\
  \ap{\CC}{(\lam{x}{\ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{M_{\mathrm{c}}})}})}
  & \to
  \ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{\ap{\CC}{(\lam{x}{M_{\mathrm{c}}})}})} \\
  & \mathrm{where\ } x \notin \FV(M_{\mathrm{p}})
\end{align*}

CRS-style:
\begin{align*}
  \ap{\CC}{(\lam{x}{\ap{\eta}{(M(x))}})} & \to \ap{\eta}{(\lam{x}{M(x)})} \\
  \ap{\CC}{(\lam{x}{\ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{M_{\mathrm{c}}(x,y)})}})}
  & \to \ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{\ap{\CC}{(\lam{x}{M_{\mathrm{c}}(x,y)})}})}
\end{align*}

We can see that the only difference is to replace ``simple'' metavariables
$M$, $M_{\mathrm{p}}$ and $M_{\mathrm{c}}$ with their higher-order
versions: the unary $M$, nullary $M_{\mathrm{p}}$ and binary
$M_{\mathrm{c}}$. We see that every CRS metavariable is applied to the
variables in scope, except for $M_{\mathrm{p}}$, which thus loses access to
the variable $x$. This way, the condition that $x$ must not appear free in
$M_{\mathrm{p}}$ is now encoded directly in the reduction rule itself.

In~\ref{ssec:crs}, we have said that a CRS is formed by a set of reduction
rules and by an alphabet. We have already seen all of the rules of our CRS
($\beta.\to$ and $\eta.\to$ were given at the end of~\ref{ssec:crs} and the
$\cherry$ rule is the same as the original one in~\ref{sec:reductions}). In
order to have a clear definition, all that remains is to identify the
alphabet.

The set of variables $Var$ is exactly the set of variables $\XX$ used in
the definition of $\banana{\lambda}$. The set of metavariables $MVar$
consists of the unary $M$, nullary $N$, nullary $N_{\mathrm{p}}$, unary
$N_{\mathrm{c}}$, nullary $M_{\mathrm{p}}$ and binary $M_{\mathrm{c}}$. The
set of function symbols is composed of the following:

\begin{itemize}
\item the binary symbol $@$ for function application
\item the unary symbol $\lambda$ for function abstraction
\item a nullary symbol for every constant in the signature $\Sigma$
\item the unary symbol $\eta$ for the injection operator
\item a binary symbol $\op{op}$ for every $\op{op} \in \EE$
\item a $(n+2)$-ary symbol
  $(\ap{\banana{\onto{\op{op}_1}{\_},\ \ldots,\ \onto{\op{op}_n}{\_},\ \onto{\eta}{\_}}}{\_})$
  for every sequence $\op{op}_1,\ldots,\op{op}_n$ of distinct symbols from
  $\EE$ of length $n$
\item the unary symbol $\cherry$ for the extraction operator
\item the unary symbol $\CC$ for the $\CC$ operator
\end{itemize}

In giving the CRS-style reduction rules above, we have used the ``native''
syntax of our calculus instead of writing out everything in terms of
function symbols. For clarity, we give the rules governing the relationship
of the two. We write:

\begin{itemize}
\item $@(t,u)$ as $\ap{t}{u}$
\item $\lambda([x]t)$ as $\lam{x}{t}$
\item $\eta(t)$ as $\etaE{t}$
\item $\op{op}(t_{\mathrm{p}},[x]t_{\mathrm{c}})$ as
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$\footnote{Note
  that with this translation,
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$ does not
  contain $\lam{x}{t_{\mathrm{c}}}$ as a subterm. This is the same as in
  our calculus, where the syntactic closure (see~\ref{sec:reductions}) does
  not identify $\lam{x}{t_{\mathrm{c}}}$, but rather $t_{\mathrm{c}}$, as a
  subterm of
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$. This becomes
  important in our discussion of confluence since it makes it impossible to
  make the $\lambda$ disappear by something like $\eta$-reduction.}
\item
  $(\ap{\banana{\onto{\op{op}_1}{\_},\ \ldots,\ \onto{\op{op}_n}{\_},\ \onto{\eta}{\_}}}{\_})(t_1,\ldots,t_n,t_\eta,u)$
  as $\ap{\banana{\onto{\op{op}_1}{t_1},\ \ldots,\ \onto{\op{op}_n}{t_n},\ \onto{\eta}{t_\eta}}}{u}$
\item $\cherry(t)$ as $\ap{\cherry}{t}$
\item $\CC(t)$ as $\ap{\CC}{t}$
\end{itemize}

We have connected the terms of $\banana{\lambda}$ with CRS terms and we
have also expressed all of our reduction rules in terms of CRS reduction
rules. As in our calculus, CRS then proceeds to take a syntactic closure of
this redex-contractum relation. Our translation from $\banana{\lambda}$ to
a CRS also preserves subterms\footnote{More precisely, if $a$ is a subterm
  of $b$ in $\banana{\lambda}$ then the CRS version of $a$ is a subterm of
  the CRS version of $b$. In the other direction, whenever $a$ is a
  variable or a function-headed term which is a subterm of $b$ in the CRS
  version of $\banana{\lambda}$, then the corresponding $a$ in
  $\banana{\lambda}$ is a subterm of the corresponding $b$ (according to
  the notion of subterm inherent in the definition of syntactic closure).}
and so we end up constructing the same reduction relation.


\subsection{Orthogonal CRSs}
\label{ssec:orthogonal-crs}

In order to use Theorem~\ref{thm:confluence-crs}, we need to show that our
CRS is orthogonal, so let us start us by looking at what ``orthogonal''
means in the context of CRSs.

\begin{definition}
  A CRS is \demph{orthogonal} if it is non-overlapping and left-linear.
\end{definition}

We will need to satisfy two criteria: no overlaps and left linearity. We
will start with the latter.

\begin{definition}
  A CRS is \demph{left-linear} if the left-hand sides of all its reduction
  rules are linear. A CRS metaterm is \demph{linear} if no metavariable
  occurs twice within it.
\end{definition}

By going through the rules we have given in~\ref{ssec:banana-as-crs}, we
can see at a glance that no rule uses the same metavariable twice in its
left-hand side and so our CRS is indeed left-linear.

\begin{definition}
  A CRS is \demph{non-overlapping} if:
  \begin{itemize}
    \item Let $r = s \to t$ be some reduction rule of the CRS and let
      $M_1$,\ldots,$M_n$ be all the metavariables occurring in the
      left-hand side $s$. Whenever we can instantiate the metavariables in
      $s$ such that the resulting term contains a redex for some other rule
      $r'$, then said redex must be contained in the instantiation of one
      of the metavariables $M_i$.
    \item Similarly, whenever we can instantiate the metavariables in $s$
      such that the resulting term \emph{properly contains} a redex
      \emph{for the same rule $r$}, then that redex as well must be
      contained in the instantiation of one of the metavariables $M_i$.
  \end{itemize}
\end{definition}

In simpler words, no left-hand side of any rule can contain bits which look
like the top of the left-hand side of some other rule. Let us try and
verify this property in our calculus:
\begin{itemize}
\item The $\banana{}$ rules have no overlaps with any of the other
  rules. Their left-hand sides are constructed only of the $\banana{}$
  symbols and the $\op{op}$ and $\eta$ constructors. Since there is no
  reduction rule headed by $\op{op}$ and $\eta$, they have no overlap with
  any of the other rules. Furthermore, the three $\banana{}$ rules are
  mutually exclusive, so there is no overlap between themselves.
\item The $\cherry$ rule does not overlap with any of the other neither,
  since the left-hand side contains only $\cherry$ and $\eta$, and there is
  no reduction rule headed by $\eta$.
\item The $\CC$ rules are both mutually exclusives, so there is no overlap
  between the two. However, their left-hand sides are built out of not only
  $\CC$, $\op{op}$ and $\eta$, but also $\lambda$, for which there is the
  $\eta.\to$ reduction rule. Fortunately in this case, the $\CC$ rules only
  apply when the $\lambda$-abstraction's body is an $\eta$ expression or an
  $\op{op}$ expression, whereas the $\eta.\to$ rule applies only when the
  body is an application expression\footnote{This is not so much a
    fortunate conincidence but rather a deliberate choice in the design of
    the calculus.}. Therefore, there is no overlap.
\end{itemize}

We have established that all the reduction rules in our system are pairwise
non-overlapping \emph{except} for $\beta.\to$ and $\eta.\to$. However,
these two are notoriously overlapping.

We can instantiate the metavariables in the left-hand side of the
$\beta.\to$ rule to get a term which contains a $\eta$-redex which shares
the $\lambda$-abstraction with the $\beta$-redex.

$$
\ap{(\lam{x}{\ap{y}{x}})}{z}
$$

We can also instantiate the metavariables in the left-hand side of the
$\eta.\to$ rule to create a $\beta$-redex which shares the application with
the $\eta$-redex.

$$
\lam{x}{\ap{(\lam{z}{z})}{x}}
$$

Our CRS is therefore \emph{not} orthogonal. However, we can still make good
use of Theorem~\ref{thm:confluence-crs}.

\begin{lemma}\label{lem:confluence-int}
  \demph{Confluence of intensional $\banana{\lambda}$}

  The $\banana{\lambda}$ reduction systems without the $\eta.\to$ rule is
  confluent.
\end{lemma}

\begin{proof}
  If we exclude the $\eta.\to$ rule, we have a CRS which is left-linear and
  also non-overlapping\footnote{We know that $\beta.\to$ does not overlap
    any of the other rules. Neither does it overlap itself since its
    left-hand side does not have an application subexpression.}. Therefore,
  it is orthogonal and thanks to Theorem~\ref{thm:confluence-crs}, also
  confluent.
\end{proof}

\begin{lemma}\label{lem:confluence-eta}
  \demph{Confluence of $\eta$-reduction}

  The reduction system on $\banana{\lambda}$ terms containing only the
  $\eta.\to$ reduction rule is confluent.
\end{lemma}

\begin{proof}
  We have seen that $\eta.\to$ is a valid left-linear CRS rule. It also
  does not overlap itself since its left-hand side does not contain any
  $\lambda$ subexpression. The CRS consisting of just the $\eta.\to$ rule
  is therefore orthogonal and confluent.
\end{proof}


\subsection{Adding $\eta.\to$ Back to $\banana{\lambda}$}

We have shown that both $\banana{\lambda}$ without $\eta.\to$ and
$\eta.\to$ by itself are confluent. The reduction relation of the complete
$\banana{\lambda}$ calculus is the union of these two reduction
relations. Using the Lemma of Hindley-Rosen (Point~2 in Exercises~1.0.8
in~\cite{klop1992term}), we can show that this union is confluent by
showing that the two reduction relations commute together.

We will not even need to know the definition of commuting reductions, since
we will base our proof on an other result due to Hindley (Point~3 in
Exercises~1.0.8 in~\cite{klop1992term}).

\begin{lemma}\label{lem:commutativity}
  Let $\to_1$ and $\to_2$ be two reduction relations on the same set of
  terms $A$. Suppose that whenever there are $a,b,c \in A$ such that $a
  \to_1 b$ and $a \to_2 c$, there is also some $d \in A$ such that $b
  \tto_2 d$ and $c \to_1^= d$ (meaning $c \to_1 d$ or $c = d$). In that
  case, $\to_1$ commutes with $\to_2$.
\end{lemma}

We can use this to prove that $\banana{\lambda}$ commutes with the
$\eta.\to$ reduction rule.

\begin{lemma}\label{lem:eta-commutes}
  \demph{Commutativity of $\eta$ and $\banana{\lambda}$}

  The reduction relations induced by $\eta$ and by the rest of the
  $\banana{\lambda}$ rules commute.
\end{lemma}

\begin{proof}
  
\end{proof}

Equipped with this lemma, we can go on to prove our main result,
Theorem~\ref{thm:confluence}, the confluence of $\banana{\lambda}$.

\begin{theorem}\label{thm:confluence}
  \demph{Confluence of $\banana{\lambda}$}
  
  The reduction relation $\to$, defined by the reduction rules
  in~\ref{sec:reductions}, on the set of $\banana{\lambda}$ terms is
  confluent.
\end{theorem}

\begin{proof}
  From Lemma~\ref{lem:confluence-int}, we know that the $\banana{\lambda}$
  system without $\eta.\to$ is confluent and from
  Lemma~\ref{lem:confluence-eta}, we know that the $\eta.\to$ reduction
  rule is confluent as well. Lemma~\ref{lem:eta-commutes} tells us that
  these two reduction systems commute and therefore, by the Lemma of
  Hindley-Rosen, their union, which is the $\banana{\lambda}$ reduction
  system, commutes as well.
\end{proof}


\section{Termination}


