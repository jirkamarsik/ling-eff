\chapter{Properties}
\label{chap:properties}


\section{Algebraic Properties}
\label{sec:algebraic-properties}


\section{Subject Reduction}


\section{Confluence}

The object of our study during this section will be the proof of the
\emph{confluence property} of $\banana{\lambda}$.

\begin{definition}
  A reduction relution $\to$ on a set $A$ is said to be \demph{confluent}
  whenever for each $a,b,c \in A$ such that $a \to b$ and $a \to c$ there
  is a $d \in A$ such that $b \tto d$ and $c \tto d$.
\end{definition}

\begin{theorem}\label{thm:confluence}
  \demph{Confluence of $\banana{\lambda}$}
  
  The reduction relation $\to$, defined by the reduction rules
  in~\ref{sec:reductions}, on the set of $\banana{\lambda}$ terms is
  confluent.
\end{theorem}

Proofs of this property are often mechanical and follow the same
pattern. Our strategy will be to reuse a general result which applies one
such proof for a general class of rewriting systems. Our rewriting system
is a system of reductions on terms and the reductions have side conditions
concerning the binding of free variables. A good fit for this kind of
system are the Combinatory Reduction Systems (CRSs) of
Klop~\cite{klop1993combinatory}.

The main result about CRSs that we will make use of is the following
(Corollary~13.6 in~\cite{klop1993combinatory}).

\begin{theorem}\label{thm:confluence-crs}
  \demph{Confluence of orthogonal CRSs}

  All orthogonal CRSs are confluent.
\end{theorem}

The rest of this section will go like this:
\begin{itemize}
\item First, we define Combinatory Reduction Systems.
\item Next, we show that our reduction relation can be coded as a CRS.
\item Afterwards, we explain the orthogonality condition.
\item Finally, we verify whether orthogonality holds for our CRS.
\end{itemize}


\subsection{Combinatory Reduction Systems}
\label{ssec:crs}

A Combinatory Reduction System is defined by an alphabet and a set of
rewriting rules. We will first cover the alphabet.

\begin{definition}
  A \demph{CRS-alphabet} consists of:
  \begin{itemize}
  \item a set $\Var$ of \emph{variables} (written lower-case as $x$, $y$,
    $z$,\ldots)
  \item a set $\MVar$ of \emph{metavariables} (written upper-case as $M$,
    $N$, \ldots), each with is own arity
  \item a set of \emph{function symbols}, each with its own arity
  \end{itemize}
\end{definition}

Let us sketch the difference between the variables in $\Var$ and the
metavariables in $\MVar$. The variables in $\Var$ are the variables of the
object-level terms, in our case it will be the variables of
$\banana{\lambda}$. The variables in $\MVar$ are the metavariables that
will occur in our reduction rules and which we will have to instantiate in
order to derive specific application of those rules. In other words, the
variables in $\Var$ are there to express the binding structure within the
terms being reduced and the metavariables in $\MVar$ are there to stand in
for specific terms when applying a reduction rule.

\begin{definition}
  The \demph{metaterms} of a CRS are given inductively:
  \begin{itemize}
  \item variables are metaterms
  \item if $t$ is a metaterm and $x$ a variable, then $[x]t$ is a metaterm
    called \emph{abstraction}
  \item if $F$ is an $n$-ary function symbol and $t_1$,\ldots,$t_n$ are
    metaterms, then $F(t_1,\ldots,t_n)$ is a metaterm
  \item if $M$ is an $n$-ary metavariable and $t_1$,\ldots,$t_n$ are
    metaterms, then $M(t_1,\ldots,t_n)$ is a metaterm
  \end{itemize}
\end{definition}

\begin{definition}
  The \demph{terms} of a CRS are its metaterms which do not contain any
  metavariables.
\end{definition}

To finish the formal introduction of CRSs, we give the definition of a CRS
reduction rule.

\begin{definition}
  A \demph{CRS-reduction rule} is a pair of metaterms $s \to t$ such that:
  \begin{itemize}
  \item $s$ and $t$ are both closed, i.e.\ all variables are bound using
    the $[\_]\_$ binder
  \item $s$ is of the form $F(t_1,\ldots,t_n)$
  \item all the metavariables that occur in $t$ also occur in $s$
  \item any metavariable $M$ that occurs in $s$ only occurs in the form
    $M(x_1,\ldots,x_k)$, where $x_i$ are pairwise distinct variables
  \end{itemize}
\end{definition}

\begin{definition}
  A \demph{Combinatory Reduction System (CRS)} is a pair of a CRS-alphabet
  and a set of CRS-reduction rules.
\end{definition}

We will only sketch the way that a CRS gives rise to a reduction relation
and we will direct curious readers to Sections~11 and 12 of
$\cite{klop1993combinatory}$.

When we instantiate the metavariables in a CRS rule, we use a
\emph{valuation} that assigns to every $n$-ary metavariable a term with
holes labelled from 1 to $n$. The instantiation of $M(t_1,\ldots,t_n)$ then
replaces the metavariable $M$ by the term with holes and fills the holes
labelled $1,\ldots,n$ with the terms $t_1,\ldots,t_n$ respectively.

The crucial detail is that in a particular context, a metavariable can only
be instantiated with terms $M$ that do not contain any free variables bound
in that context. This means that for the instantiation of $M$ to contain a
variable bound in the context, $M$ must explicitly take that variable as an
argument. All other variables not explicitly declared can therefore be
safely assumed to not occur freely within.

Consider the following examples of $\beta$ and $\eta$ reduction.

\begin{align*}
  \ap{(\lam{x}{M(x)})}{N} & \to M(N) \\
  \lam{x}{\ap{N}{x}} & \to N
\end{align*}

More formally written as:

\begin{align*}
  @(\lambda([x]M(x)),N) & \to M(N) \\
  \lambda([x]@(N,x)) & \to N
\end{align*}

where $\lambda$ is a unary function symbol and $@$ is a binary function
symbol. In both of the versions, $M$ is a unary metavariable and $N$ is a
nullary metavariable. In the rule for $\beta$-reduction, we can observe how
the idea of instantiating metavariables by terms with holes lets us express
the same idea for which we had to introduce the meta-level operation of
substitution. In the rule for $\eta$-reduction, we see that $N$ appears in
a context where $x$ is bound but it does not have $x$ as one of its
arguments. Therefore, it will be impossible to instantiate $N$ in such a
way that it contains a free occurrence of $x$. In both of those rules, we
were able to get rid of meta-level operations (substitution) and conditions
($x \notin FV(N)$) and have them both implemented by the formalism itself.


\subsection{$\banana{\lambda}$ as a CRS}
\label{ssec:banana-as-crs}

We will now see how to rephrase the reduction rules of our calculus in
order to fit in to the CRS framework. We have already seen how to translate
the $\beta.\to$ and $\eta.\to$ rules in the previous subsection. The next
rules to address are the rules defining the semantics of the $\banana{}$
handlers.

We will repeat the rules for handlers to make the issue at hand clear.

\begin{tabular}{lr}
  $\ap{\cibanana}{(\ap{\eta}{N})} \to$ & rule $\banana{\eta}$ \\
  $\ap{M_\eta}{N}$ & \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}_j}{N_{\mathrm{p}}}}{(\lam{x}{N_{\mathrm{c}}})})} \to$ & rule $\banana{\op{op}}$ \\
  $\ap{M_j}{\ap{N_{\mathrm{p}}}{(\lam{x}{\ap{\cibanana}{N_{\mathrm{c}}}})}}$
  & where $j \in I$ \\
  & and $x \notin \FV((M_i)_{i \in I}, M_\eta)$ \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}_j}{N_{\mathrm{p}}}}{(\lam{x}{N_{\mathrm{c}}})})} \to$ & rule $\banana{\op{op}'}$ \\
  $\ap{\op{op}_j}{\ap{N_{\mathrm{p}}}{(\lam{x}{\ap{\cibanana}{N_{\mathrm{c}}}})}}$
  & where $j \notin I$ \\
  & and $x \notin \FV((M_i)_{i \in I}, M_\eta)$
\end{tabular}

\TODO{Make sure later that the form of these rules in the Definitions
  chapter is the same as the one above.}

The syntax of CRSs does not allow us to use the $(\onto{\op{op}_i}{M_i})_{i
  \in I}$ notation nor capture the $j \in I$ or $j \notin I$ conditions.
The symbols $\op{op}_i$ are problematic as well, since technically, they
are not pure $\banana{\lambda}$ syntax but metavariables standing in for
operation symbols.

We do away with all of the above problems by expanding these meta-notations
and adding a separate rule for every possible instantiation of the
schema. This means that for each sequence of distinct operation symbols
$\op{op}_1$,\ldots,$\op{op}_n$, we end up with:
\begin{itemize}
\item a special rewriting rule
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\etaE{N})}
  \to \ap{M_\eta}{N}$
\item for every $1 \le i \le n$, a special rewriting rule \\
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\app{\op{op}_i}{N_{\mathrm{p}}}{(\lam{x}{N_{\mathrm{c}}(x)})})}
  \\ \to
  \app{M_i}{N_{\mathrm{p}}}{(\lam{x}{\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ \onto{\eta}{M_\eta}}}{N_{\mathrm{c}}(x)}})}$
\item for every $\op{op}' \in \EE \setminus \{\op{op}_i \| 1 \le i \le n\}$, a special
  rewriting rule \\
  $\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ 
    \onto{\eta}{M_\eta}}}{(\app{\op{op}'}{N_{\mathrm{p}}}{(\lam{x}{N_{\mathrm{c}}(x)})})}
  \\ \to
  \app{\op{op}'}{N_{\mathrm{p}}}{(\lam{x}{\ap{\banana{\onto{\op{op}_1}{M_1},\ldots,\onto{\op{op}_n}{M_n},\ \onto{\eta}{M_\eta}}}{N_{\mathrm{c}}(x)}})}$
\end{itemize}

The rule for the cherry $\cherry$ extraction operator is already in CRS
form, so all we have to do is address the rules for the $\CC$ operator. We
present them side-by-side in their original form and in CRS-style.

Original:
\begin{align*}
  \ap{\CC}{(\lam{x}{\ap{\eta}{M}})} & \to \ap{\eta}{(\lam{x}{M})} \\
  \ap{\CC}{(\lam{x}{\ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{M_{\mathrm{c}}})}})}
  & \to
  \ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{\ap{\CC}{(\lam{x}{M_{\mathrm{c}}})}})} \\
  & \mathrm{where\ } x \notin \FV(M_{\mathrm{p}})
\end{align*}

CRS-style:
\begin{align*}
  \ap{\CC}{(\lam{x}{\ap{\eta}{(M(x))}})} & \to \ap{\eta}{(\lam{x}{M(x)})} \\
  \ap{\CC}{(\lam{x}{\ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{M_{\mathrm{c}}(x,y)})}})}
  & \to \ap{\ap{\op{op}}{M_{\mathrm{p}}}}{(\lam{y}{\ap{\CC}{(\lam{x}{M_{\mathrm{c}}(x,y)})}})}
\end{align*}

We can see that the only difference is to replace ``simple'' metavariables
$M$, $M_{\mathrm{p}}$ and $M_{\mathrm{c}}$ with their higher-order
versions: the unary $M$, nullary $M_{\mathrm{p}}$ and binary
$M_{\mathrm{c}}$. We see that every CRS metavariable is applied to the
variables in scope, except for $M_{\mathrm{p}}$, which thus loses access to
the variable $x$. This way, the condition that $x$ must not appear free in
$M_{\mathrm{p}}$ is now encoded directly in the reduction rule itself.

In~\ref{ssec:crs}, we have said that a CRS is formed by a set of reduction
rules and by an alphabet. We have already seen all of the rules of our CRS
($\beta.\to$ and $\eta.\to$ were given at the end of~\ref{ssec:crs} and the
$\cherry$ rule is the same as the original one in~\ref{sec:reductions}). In
order to have a clear definition, all that remains is to identify the
alphabet.

The set of variables $Var$ is exactly the set of variables $\XX$ used in
the definition of $\banana{\lambda}$. The set of metavariables $MVar$
consists of the unary $M$, nullary $N$, nullary $N_{\mathrm{p}}$, unary
$N_{\mathrm{c}}$, nullary $M_{\mathrm{p}}$ and binary $M_{\mathrm{c}}$. The
set of function symbols is composed of the following:

\begin{itemize}
\item the binary symbol $@$ for function application
\item the unary symbol $\lambda$ for function abstraction
\item a nullary symbol for every constant in the signature $\Sigma$
\item the unary symbol $\eta$ for the injection operator
\item a binary symbol $\op{op}$ for every $\op{op} \in \EE$
\item a $(n+2)$-ary symbol
  $(\ap{\banana{\onto{\op{op}_1}{\_},\ \ldots,\ \onto{\op{op}_n}{\_},\ \onto{\eta}{\_}}}{\_})$
  for every sequence $\op{op}_1,\ldots,\op{op}_n$ of distinct symbols from
  $\EE$ of length $n$
\item the unary symbol $\cherry$ for the extraction operator
\item the unary symbol $\CC$ for the $\CC$ operator
\end{itemize}

In giving the CRS-style reduction rules above, we have used the ``native''
syntax of our calculus instead of writing out everything in terms of
function symbols. For clarity, we give the rules governing the relationship
of the two. We write:

\begin{itemize}
\item $@(t,u)$ as $\ap{t}{u}$
\item $\lambda([x]t)$ as $\lam{x}{t}$
\item $\eta(t)$ as $\etaE{t}$
\item $\op{op}(t_{\mathrm{p}},[x]t_{\mathrm{c}})$ as
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$\footnote{Note
  that with this translation,
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$ does not
  contain $\lam{x}{t_{\mathrm{c}}}$ as a subterm. This is the same as in
  our calculus, where the syntactic closure (see~\ref{sec:reductions}) does
  not identify $\lam{x}{t_{\mathrm{c}}}$, but rather $t_{\mathrm{c}}$, as a
  subterm of
  $\app{\op{op}}{t_{\mathrm{p}}}{(\lam{x}{t_{\mathrm{c}}})}$. This becomes
  important in our discussion of confluence since it makes it impossible to
  make the $\lambda$ disappear by something like $\eta$-reduction.}
\item
  $(\ap{\banana{\onto{\op{op}_1}{\_},\ \ldots,\ \onto{\op{op}_n}{\_},\ \onto{\eta}{\_}}}{\_})(t_1,\ldots,t_n,t_\eta,u)$
  as $\ap{\banana{\onto{\op{op}_1}{t_1},\ \ldots,\ \onto{\op{op}_n}{t_n},\ \onto{\eta}{t_\eta}}}{u}$
\item $\cherry(t)$ as $\ap{\cherry}{t}$
\item $\CC(t)$ as $\ap{\CC}{t}$
\end{itemize}

We have connected the terms of $\banana{\lambda}$ with CRS terms and we
have also expressed all of our reduction rules in terms of CRS reduction
rules. As in our calculus, CRS then proceeds to take a syntactic closure of
this redex-contractum relation. Our translation from $\banana{\lambda}$ to
a CRS also preserves subterms\footnote{More precisely, if $a$ is a subterm
  of $b$ in $\banana{\lambda}$ then the CRS version of $a$ is a subterm of
  the CRS version of $b$. In the other direction, whenever $a$ is a
  variable or a function-headed term which is a subterm of $b$ in the CRS
  version of $\banana{\lambda}$, then the corresponding $a$ in
  $\banana{\lambda}$ is a subterm of the corresponding $b$ (according to
  the notion of subterm inherent in the definition of syntactic closure).}
and so we end up constructing the same reduction relation.


\subsection{Orthogonal CRSs}
\label{ssec:orthogonal-crs}

In order to use Theorem~\ref{thm:confluence-crs}, we need to show that our
CRS is orthogonal, so let us start us by looking at what ``orthogonal''
means in the context of CRSs.

\begin{definition}
  A CRS is \demph{orthogonal} if it is non-overlapping and left-linear.
\end{definition}

We will need to satisfy two criteria: no overlaps and left linearity. We
will start with the latter.

\begin{definition}
  A CRS is \demph{left-linear} if the left-hand sides of all its reduction
  rules are linear. A CRS metaterm is \demph{linear} if no metavariable
  occurs twice within it.
\end{definition}

By going through the rules we have given in~\ref{ssec:banana-as-crs}, we
can see at a glance that no rule uses the same metavariable twice in its
left-hand side and so our CRS is indeed left-linear.

\begin{definition}
  A CRS is \demph{non-overlapping} if:
  \begin{itemize}
    \item Let $r = s \to t$ be some reduction rule of the CRS and let
      $M_1$,\ldots,$M_n$ be all the metavariables occurring in the
      left-hand side $s$. Whenever we can instantiate the metavariables in
      $s$ such that the resulting term contains a redex for some other rule
      $r'$, then said redex must be contained in the instantiation of one
      of the metavariables $M_i$.
    \item Similarly, whenever we can instantiate the metavariables in $s$
      such that the resulting term \emph{properly contains} a redex
      \emph{for the same rule $r$}, then that redex as well must be
      contained in the instantiation of one of the metavariables $M_i$.
  \end{itemize}
\end{definition}

In simpler words, no left-hand side of any rule can contain bits which look
like the top of the left-hand side of some other rule. Let us try and
verify this property in our calculus:
\begin{itemize}
\item The $\banana{}$ rules have no overlaps with any of the other
  rules. Their left-hand sides are constructed only of the $\banana{}$
  symbols and the $\op{op}$ and $\eta$ constructors. Since there is no
  reduction rule headed by $\op{op}$ and $\eta$, they have no overlap with
  any of the other rules. Furthermore, the three $\banana{}$ rules are
  mutually exclusive, so there is no overlap between themselves.
\item The $\cherry$ rule does not overlap with any of the other neither,
  since the left-hand side contains only $\cherry$ and $\eta$, and there is
  no reduction rule headed by $\eta$.
\item The $\CC$ rules are both mutually exclusives, so there is no overlap
  between the two. However, their left-hand sides are built out of not only
  $\CC$, $\op{op}$ and $\eta$, but also $\lambda$, for which there is the
  $\eta.\to$ reduction rule. Fortunately in this case, the $\CC$ rules only
  apply when the $\lambda$-abstraction's body is an $\eta$ expression or an
  $\op{op}$ expression, whereas the $\eta.\to$ rule applies only when the
  body is an application expression\footnote{This is not so much a
    fortunate conincidence but rather a deliberate choice in the design of
    the calculus.}. Therefore, there is no overlap.
\end{itemize}

We have established that all the reduction rules in our system are pairwise
non-overlapping \emph{except} for $\beta.\to$ and $\eta.\to$. However,
these two are notoriously overlapping.

We can instantiate the metavariables in the left-hand side of the
$\beta.\to$ rule to get a term which contains a $\eta$-redex which shares
the $\lambda$-abstraction with the $\beta$-redex.

$$
\ap{(\lam{x}{\ap{y}{x}})}{z}
$$

We can also instantiate the metavariables in the left-hand side of the
$\eta.\to$ rule to create a $\beta$-redex which shares the application with
the $\eta$-redex.

$$
\lam{x}{\ap{(\lam{z}{z})}{x}}
$$

Our CRS is therefore \emph{not} orthogonal. However, we can still make good
use of Theorem~\ref{thm:confluence-crs}.

\begin{lemma}\label{lem:confluence-int}
  \demph{Confluence of intensional $\banana{\lambda}$}

  The $\banana{\lambda}$ reduction systems without the $\eta.\to$ rule is
  confluent.
\end{lemma}

\begin{proof}
  If we exclude the $\eta.\to$ rule, we have a CRS which is left-linear and
  also non-overlapping\footnote{We know that $\beta.\to$ does not overlap
    any of the other rules. Neither does it overlap itself since its
    left-hand side does not have an application subexpression.}. Therefore,
  it is orthogonal and thanks to Theorem~\ref{thm:confluence-crs}, also
  confluent.
\end{proof}

\begin{lemma}\label{lem:confluence-eta}
  \demph{Confluence of $\eta$-reduction}

  The reduction system on $\banana{\lambda}$ terms containing only the
  $\eta.\to$ reduction rule is confluent.
\end{lemma}

\begin{proof}
  We have seen that $\eta.\to$ is a valid left-linear CRS rule. It also
  does not overlap itself since its left-hand side does not contain any
  $\lambda$ subexpression. The CRS consisting of just the $\eta.\to$ rule
  is therefore orthogonal and confluent.
\end{proof}


\subsection{Adding $\eta.\to$ Back to $\banana{\lambda}$}

We have shown that both $\banana{\lambda}$ without $\eta.\to$ and
$\eta.\to$ by itself are confluent. The reduction relation of the complete
$\banana{\lambda}$ calculus is the union of these two reduction
relations. Using the Lemma of Hindley-Rosen (Point~2 in Exercises~1.0.8
in~\cite{klop1992term}), we can show that this union is confluent by
showing that the two reduction relations commute together.

We will not even need to know the definition of commuting reductions, since
we will base our proof on an other result due to Hindley (Point~3 in
Exercises~1.0.8 in~\cite{klop1992term}).

\begin{lemma}\label{lem:commutativity}
  Let $\to_1$ and $\to_2$ be two reduction relations on the same set of
  terms $A$. Suppose that whenever there are $a,b,c \in A$ such that
  $a \to_1 b$ and $a \to_2 c$, there is also some $d \in A$ such that
  $b \tto_2 d$ and $c \to_1^= d$ (meaning $c \to_1 d$ or $c = d$). In that
  case, $\to_1$ commutes with $\to_2$.
\end{lemma}

We can use this to prove that $\banana{\lambda}$ commutes with the
$\eta.\to$ reduction rule.

\begin{lemma}\label{lem:eta-commutes}
  \demph{Commutativity of $\eta$ and $\banana{\lambda}_{-\eta}$}

  The reduction relations induced by $\eta$ and by the rest of the
  $\banana{\lambda}$ rules commute.
\end{lemma}

\begin{proof}
  We will prove this lemma by an appeal to
  Lemma~\ref{lem:commutativity}. Let $\to_\eta$ be the reduction relation
  induced by the rule $\eta.\to$ and $\to_{\banana{\lambda}}$ the reduction
  relation induced by all the other reduction rules in
  $\banana{\lambda}$. We need to prove that for all terms $a$, $b$ and $c$
  where $a \to_{\calc} b$ and $a \to_\eta c$, we have a term $d$ such that
  $b \tto_\eta d$ and $c \to_{\calc}^= d$.

  This will turn out to be a routine proof by induction on the structure of
  the term $a$. The base cases are trivial since terms without any proper
  subterms happen to have no redexes in our calculus and therefore
  trivially satisfy the criterion. In the inductive step, we will proceed
  by analyzing the relative positions of the redexes which led to the
  reductions $a \to_{\calc} b$ and $a \to_\eta c$.
  \begin{itemize}
  \item If both reductions occurred within a common subterm of $a$, i.e.\
    $a = C[a']$, $b = C[b']$ and $c = C[c']$ while at the same time
    $a' \to_{\calc} b'$ and $a' \to_\eta c'$: We can use the induction
    hypothesis for $a'$. This gives us a $d'$ such that $b' \tto_\eta d'$
    and $c' \to_{\calc}^= d'$ and therefore we also have $d = C[d']$ with
    $b \tto_\eta d$ and $c \to_{\calc}^= d$.
  \item If both reductions occurred within non-overlapping subterms of $a$,
    i.e.\ $a = C[a_1, a_2]$, $b = C[b', a_2]$ and $c = C[a_1, c']$ with
    $a \to_{\calc} b$ and $a \to_\eta c$: We can take $d = C[b', c']$ since
    we have $b \tto_\eta d$ in one step and $c \to_{\calc}^= d$ in one step
    too.
  \item If the redex in $a \to_{\calc} b$ is the entire term $a$, but the
    redex in $a \to_\eta c$ is a proper subterm of $a$: We will solve this
    by case analysis on the form of $a$:
    \begin{itemize}
    \item If $a$ is an application: Since $a$ is an application and also a
      $\banana{\lambda}$-redex, it must match the left-hand side of the
      $\beta.\to$ rule, $\ap{(\lam{x}{M(x)})}{N}$, and $b$ must be $M(N)$.
      \begin{itemize}
      \item We will first deal with the case when the $\eta$-redex which
        lead to $c$ originated in $M(x)$. In that case
        $M(x) \to_\eta M'(x)$ and $c = \ap{(\lam{x}{M'(x)})}{N}$. Our
        sought-after $d$ is then $M'(N)$, since $c \to_{\calc}^= d$ via
        $\beta.\to$ in one step and $b = M(N) \tto_\eta d = M'(N)$.
      \item Now we get to one of the two interesting cases which
        necessitated this whole lemma: the overlap between $\beta$ and
        $\eta$, with $\beta$ on the top. If the $\eta$-redex did not
        originate in $M(x)$, then the $\eta$-redex must be
        $\lam{x}{M(x)}$. Therefore, $M = \ap{T}{x}$ and
        $a = \ap{(\lam{x}{\ap{T}{x}})}{N}$. Performing the $\eta$-reduction
        yields $c = \ap{T}{N}$. In this case, both $b$ and $c$ are equal to
        $\ap{T}{N}$ and so we can choose $\ap{T}{N}$ as our $d$.
      \end{itemize}
    \item If $a$ is any other kind of term: Let $l \to r$ be the rule used
      in $a \to_{\calc} b$. Not counting $\beta.\to$, which only acts on
      applications and which we dealt with just above, the rules of
      $\banana{\lambda}$ do not overlap with the $\eta.\to$ rule. This
      means the $\eta$-redex which led to $c$ must lie entirely inside a
      part the part of $l$ which corresponds to a metavariable. Let $M$ be
      that metavariable, then we will decompose $l$ into $L(M)$ and $r$
      into $R(M)$. We have $a = L(a')$ for some $a'$, $b = R(a')$ and
      $c = L(a'')$\footnote{Since our rules are left-linear, $M$ is
        guaranteed to appear in $L(M)$ at most once. Therefore, if
        $a' \to_\eta a''$ in one step, then also $L(a') \to_\eta L(a'')$ in
        one step as well.}. Our $d$ will be $R(a'')$ and we have
      $b = R(a') \tto_\eta d = R(a'')$ in several steps\footnote{$a'$ can
        occur multiple times in $R(a')$ when the rule $l \to r$ is
        duplicating (which is actually the case for the $\banana{\op{op}}$
        rules). However, we are able to go from $R(a')$ to $R(a'')$ in
        multiple steps. NB: This is why we use
        Lemma~\ref{lem:commutativity} instead of trying to prove
        commutativity directly.} and $c = L(a'') \to_{\calc}^= d = R(a'')$
      in one step of $l \to r$.
    \end{itemize}
  \item If the redex in $a \to_\eta c$ is the entire term $a$, but the
    redex in $a \to_{\calc} b$ is a proper subterm of $a$: In this case,
    $a$ must be an abstraction that matches the left-hand side of the
    $\eta.\to$ rule, i.e.\ $a = \lam{x}{\ap{N}{x}}$. Also, we have $c = N$.
    \begin{itemize}
    \item As before, we will first deal with the case when the
      $\banana{\lambda}$-redex is contained completely within $N$. Then
      $N \to_{\calc} N'$ and $b = \lam{x}{\ap{N'}{x}}$. The common reduct
      $d$ is $N'$ since $b \tto_\eta d$ in one step and
      $c = N \to_{\calc}^= d = N'$ as established before.
    \item Now this is where we deal with the second overlap between $\beta$
      and $\eta$ in our reduction system, the one with $\eta$ on top. Let
      us assume that the $\banana{\lambda}$-redex in $a$ is actually
      $\ap{N}{x}$. Since this is an application, the only admissible
      reduction is with $\beta.\to$. In that case, $N = \lam{y}{T(y)}$ and
      $a = \lam{x}{\ap{(\lam{y}{T(y)})}{x}}$. Performing the
      $\beta$-reduction gives us $b = \lam{x}{T(x)}$ which is however equal
      to $c = N = \lam{y}{T(y)}$. So we can choose $d = b$ and be done.
    \end{itemize}
  \item If $a$ is the redex for both reductions $a \to_{\calc} b$ and
    $a \to_\eta c$, then $a$ must match the left-hand side of two reduction
    rules. However, that is impossible in our calculus and so $a$ must have
    matched the same rule twice and therefore $b = c$. Then, we have a
    trivial $d = b$.
  \end{itemize}
\end{proof}

Equipped with this lemma, we can go on to prove our main result,
Theorem~\ref{thm:confluence}, the confluence of $\banana{\lambda}$.

\begin{theorem}\label{thm:confluence}
  \demph{Confluence of $\banana{\lambda}$}
  
  The reduction relation $\to$, defined by the reduction rules
  in~\ref{sec:reductions}, on the set of $\banana{\lambda}$ terms is
  confluent.
\end{theorem}

\begin{proof}
  From Lemma~\ref{lem:confluence-int}, we know that the $\banana{\lambda}$
  system without $\eta.\to$ is confluent and from
  Lemma~\ref{lem:confluence-eta}, we know that the $\eta.\to$ reduction
  rule is confluent as well. Lemma~\ref{lem:eta-commutes} tells us that
  these two reduction systems commute and therefore, by the Lemma of
  Hindley-Rosen, their union, which is the $\banana{\lambda}$ reduction
  system, commutes as well.
\end{proof}


\section{Termination}
\label{sec:termination}

We will prove termination with a similar strategy. $\banana{\lambda}$ is an
extension of the $\lambda$-calculus with computation types and some
operations on computations. Our computations can be thought of as algebraic
expressions, i.e.\ they have a tree-like inductive structure. The reason
that all computations in our calculus terminate is that the operations
defined on computations rely on well-founded recursion. However, it is
quite tricky to go from this intuition to a formal proof of
termination. Fortunately, we can rely on existing results.

Blanqui, Jounnaud and Okada have introduced Inductive Data Type Systems
(IDTSs)~\cite{blanqui2002inductive,blanqui2000termination}. Similar to the
CRSs, IDTSs are a class of rewriting systems for which we can prove certain
interesting general results. In this section, we will start by examining
the definition of an IDTS and fitting our calculus into that
definition. Then, we will verify that the IDTS version of our calculus
satisfies the sufficient conditions for being a terminating IDTS and thus
end up with a proof of termination for our calculus.

\subsection{Defining Inductive Data Type Systems}
\label{ssec:defining-idtss}

We will go by the revised definition of Inductive Data Type Systems that
figures in~\cite{blanqui2000termination}. This formulation extends IDTSs to
higher-order rewriting and does so using the CRS formalism that we
introduced earlier.

\begin{definition}
  An \demph{Inductive Data Type System (IDTS)} is a pair of an IDTS-alphabet
  and a set of IDTS-rewrite rules.
\end{definition}

Just like a CRS, an IDTS is an alphabet coupled with some rewrite
rules. Let us first look at the alphabet and the rules for building terms
out of the elements of the alphabet; the rewrite rules will follow.

\begin{definition}
  The set of types $T(\BB)$ contains:
  \begin{itemize}
  \item all the types from $\BB$
  \item a type $\alpha \to \beta$ for every $\alpha$ and $\beta$ in $T(\BB)$
  \end{itemize}
\end{definition}

\begin{definition}
  An \demph{IDTS-alphabet} consists of:
  \begin{itemize}
  \item $\BB$, a set of \emph{base types}
  \item $\XX$, a family $(X_\tau)_{\tau \in T(\BB)}$ of sets of \emph{variables}
  \item $\FF$, a family ${(F_{\alpha_1,\ldots,\alpha_n,\beta})}_{\alpha_1,\ldots,\alpha_n,\beta \in T(\BB)}$ of sets of \emph{function symbols}
  \item $\ZZ$, a family ${(Z_{\alpha_1,\ldots,\alpha_n,\beta})}_{\alpha_1,\ldots,\alpha_n,\beta \in T(\BB)}$ of sets of
    \emph{metavariables}
  \end{itemize}
\end{definition}

The distinction between a CRS-alphabet and an IDTS-alphabet is that the
IDTS-alphabet comes equipped with a set of types. Furthermore, all the
other symbols in the alphabet are indexed by types, so we end up with typed
variables, typed function symbols and typed metavariables.

When we consider IDTS metaterms, we admit only well-typed terms. The below
definition of IDTS metaterms refines the definition of CRS metaterms by
restraining term formation in accordance with the types.

\begin{definition}
  The \demph{typed metaterms} of an IDTS are given inductively:
  \begin{itemize}
  \item variables from $X_\tau$ are metaterms of type $\tau$
  \item if $t$ is a metaterm of type $\beta$ and $x$ a variable from
    $X_\alpha$, then $[x]t$ is a metaterm of type $\alpha \to \beta$ called
    \emph{abstraction}
  \item if $F$ is an function symbol from
    $F_{\alpha_1,\ldots,\alpha_n,\beta}$ and $t_1$,\ldots,$t_n$ are
    metaterms of types $\alpha_1,\ldots,\alpha_n$, respectively, then
    $F(t_1,\ldots,t_n)$ is a metaterm of type $\beta$
  \item if $M$ is a metavariable from $Z_{\alpha_1,\ldots,\alpha_n,\beta}$
    and $t_1$,\ldots,$t_n$ are metaterms of types
    $\alpha_1,\ldots,\alpha_n$, respectively, then $M(t_1,\ldots,t_n)$ is a
    metaterm of type $\beta$
  \end{itemize}
\end{definition}

\begin{definition}
  The \demph{terms} of an IDTS are its metaterms which do not contain any
  metavariables.
\end{definition}

The definition of an IDTS rewrite rule is almost identical to the one for
CRS reduction rules. The only difference is the extra condition stating
that the redex and contractum must have identical types.

\begin{definition}
  An \demph{IDTS rewrite rule} is a pair of metaterms $s \to t$ such that:
  \begin{itemize}
  \item $s$ and $t$ are both closed, i.e.\ all variables are bound using
    the $[\_]\_$ binder
  \item $s$ is of the form $F(t_1,\ldots,t_n)$
  \item all the metavariables that occur in $t$ also occur in $s$
  \item any metavariable $M$ that occurs in $s$ only occurs in the form
    $M(x_1,\ldots,x_k)$, where $x_i$ are pairwise distinct variables
  \item $s$ and $t$ are both of the same type
  \end{itemize}
\end{definition}

As stated above, an IDTS is just an alphabet along with a set of rewrite
rules. An IDTS induces a rewriting relation in exactly the same way as a
CRS does, see~\cite{blanqui2000termination} for more details.


\subsection{$\banana{\lambda}$ as an Inductive Data Type System}
\label{ssec:banana-idts}

Now we will try to link our calculus to the IDTS framework in order to
benefit from its general termination results. The biggest obstacle will be
that IDTS assigns a fixed type to every symbol. In our calculus, symbols
are polymorphic: the $\eta$ constructor can produce expressions like
$\etaE{\star} : \FF_E(1)$ or $\etaE{(\lam{x}{x})} : \FF_E(\alpha \to
\alpha)$ and that for any choice of $E$. We would therefore like to replace
function symbols such as $\eta$ with specialized symbols
$\eta_{\FF_E(\alpha)}$. For a given type $\alpha$ and effect signature $E$,
the symbol $\eta_{\FF_E(\alpha)}$ would have the type $\alpha \to
\FF_E(\alpha)$, i.e.\ it would belong to $F_{\alpha,\FF_E(\alpha)}$.

We will call this calculus with specialized symbols
$\banana{\lambda}_\tau$. There will not be a bijection between
$\banana{\lambda}$ and $\banana{\lambda}_\tau$ since a single term in
$\banana{\lambda}$ will generally correspond to a multitude of specialized
versions in $\banana{\lambda}_\tau$ (think of $\lam{x}{x}$ in
$\banana{\lambda}$ versus $\lam{x_\iota}{x_\iota}$, $\lam{x_o}{x_o}$\ldots
in $\banana{\lambda}_\tau$). Therefore, the results we prove for
$\banana{\lambda}_\tau$ will not automatically transfer to
$\banana{\lambda}$. In the rest of this subsection, we will elaborate the
definition of $\banana{\lambda}_\tau$ and show why termination carries over
from $\banana{\lambda}_\tau$ to $\banana{\lambda}$.


\subsubsection{$\banana{\lambda}_\tau$}
\label{sssec:banana-tau}

$\banana{\lambda}_\tau$ will be defined as an IDTS. This means we need to
first identify the alphabet. The base types $\BB$ of
$\banana{\lambda}_\tau$ will be all the atomic types and computation types
of $\banana{\lambda}$ (i.e.\ all types except for function types). This
means that the set of types $T(\BB)$ of $\banana{\lambda}_\tau$ will be
exactly the set of types of $\banana{\lambda}$.

Next, we will introduce function symbols for all the syntactic
constructions of $\banana{\lambda}$ except for abstraction, which is
handled by the $[\_]\_$ binder construct already found in IDTSs:

\begin{itemize}
\item $@_{\alpha, \beta} \in F_{\alpha \to \beta, \alpha, \beta}$
  (i.e.\ for every pair of types $\alpha$ and $\beta$, there will be a
  function symbol $@_{\alpha,\beta}$ of type $(\alpha \to \beta) \to
  \alpha \to \beta$ in our alphabet)
\item $c \in F_{\alpha}$ for any constant $c : \alpha \in \Sigma$
\item $\eta_{\FF_E(\alpha)} \in F_{\alpha, \FF_E(\alpha)}$
\item $\op{op}_{\FF_E(\gamma)} \in F_{\alpha, \beta \to \FF_E(\gamma),
  \FF_E(\gamma)}$ for any operation symbol $\op{op}$ from $\EE$ and any $E$
  such that $\typedop{op}{\alpha}{\beta} \in E$
\item $\cherry_\alpha \in F_{\FF_\emptyset(\alpha), \alpha}$
\item $\banana{}_{\op{op}_1, \ldots, \op{op}_n, \FF_E(\gamma),
  \FF_{E'}(\delta)} \in F_{\alpha_1 \to (\beta_1 \to \FF_{E'}(\delta)), \ldots,
  \alpha_n \to (\beta_n \to \FF_E'(\delta)), \gamma \to \FF_{E'}(\delta),
  \FF_E(\gamma), \FF_{E'}(\delta)}$ where:
  \begin{itemize}
  \item $\op{op}_1 : \alpha_1 \rightarrowtail \beta_1 \in E$, \ldots,
    $\op{op}_n : \alpha_n \rightarrowtail \beta_n \in E$
  \item $E \setminus \{\op{op}_1, \ldots, \op{op}_n\} \subseteq E'$
  \end{itemize}
\item $\CC_{\alpha,\beta,E} \in F_{\alpha \to \FF_E(\beta),\FF_E(\alpha \to
  \beta)}$
\end{itemize}

The list above is based on the typing rules of our calculus found on
Figure~\ref{fig:types}. The idea behind the conversion from our typing
rules to this list of typed symbols is to index every symbol by the type
and effect signature metavariables that appear in the conclusion of the
symbol's typing rule. A specifically-typed symbol in
$\banana{\lambda}_\tau$ then corresponds to an instantiation of the type
metavariables in a $\banana{\lambda}$ typing rule.

Our alphabet now has types and function symbols. For variables and
metavariables, we will take some arbitrary sets containing\ldots \TODO{Put
  the variables and metavariables used in the rules below in here.}.

To complete our IDTS, we have to give the rewrite rules. The rules for
$\banana{\lambda}_\tau$ are given in Figure~\ref{fig:tau-types}.

\begin{figure}
  \centering
  \begin{tabular}{lr}
  $@_{\alpha, \beta}([x_\alpha]M_{\alpha, \beta}(x_\alpha), N_\alpha) \to$ & rule $\beta_{\alpha, \beta}$ \\
  $M_{\alpha, \beta}(N_\alpha)$ & \\
  \\
  $\ap{\cibanana}{(\ap{\eta}{N})} \to$ & rule $\banana{\eta}$ \\
  $\ap{M_\eta}{N}$ & \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}_i}{N_p}}{(\lam{x}{N_c})})} \to$ & rule $\banana{\op{op}}$ \\
  $\ap{M_i}{\ap{N_p}{(\lam{x}{\ap{\cibanana}{N_c}})}}$
  & where $x$ is fresh for $M_\eta$ \\ & and $M_i$ for all $i \in I$ \\
  \\
  $\ap{\cibanana}{(\ap{\ap{\op{op}'}{N_p}}{(\lam{x}{N_c})})} \to$ & rule $\banana{\op{op}'}$ \\
  $\ap{\op{op}'}{\ap{N_p}{(\lam{x}{\ap{\cibanana}{N_c}})}}$
  & where $\op{op}' \notin \{\op{op}_i\}_{i \in I}$ \\
  & and $x$ is fresh for $M_\eta$ \\ & and $M_i$ for all $i \in I$ \\
  \\
  $\ap{\cherry}{(\ap{\eta}{N})} \to$ & rule $\cherry$ \\
  $N$ & \\
  \\
  $\ap{\CC}{(\lam{x}{\ap{\eta}{M}})} \to$ & rule $\CC_\eta$ \\
  $\ap{\eta}{(\lam{x}{M})}$ & \\
  \\
  $\ap{\CC}{(\lam{x}{\ap{\ap{\op{op}}{M_p}}{(\lam{y}{M_c})}})} \to$ & rule $\CC_\op{op}$ \\
  $\ap{\ap{\op{op}}{M_p}}{(\lam{y}{\ap{\CC}{(\lam{x}{M_c})}})}$
  & where $x$ is fresh for $M_p$
  \end{tabular}
  
  \caption{\label{fig:tau-types} IDTS rewrite rules for
    $\banana{\lambda}_\tau$.}
  
\end{figure}
