;; Manipulating Terms
;; ==================
;;
;; Defined below are utility functions that allow us to normalize and
;; pretty-print terms.

;; simplify-logic is a reduction relation that implements some simple
;; logical rules.  Their point is to sanitize the logical formulas
;; generated by our system by, e.g., decoding the logical operators
;; ∀, ⇒ and ∨.
(define simplify-logic
  (compatible-closure
    (reduction-relation BANANA+SPA #:domain e
      (--> ((∧ e) ⊤)
           e)
      (--> ((∧ ⊤) e)
           e)
      (--> (¬ (¬ e))
           e)
      (--> (¬ (∃ (λ (x) e)))
           (∀ (λ (x) (¬ e))))
      (--> (¬ (∀ (λ (x) e)))
           (∃ (λ (x) (¬ e))))
      (--> (¬ ((∧ e_1) (¬ e_2)))
           ((⇒ e_1) e_2))
      (--> (¬ ((∧ e_1) (∀ (λ (x) (¬ e_2)))))
           ((⇒ e_1) (∃ (x) e_2)))
      (--> (¬ ((∧ (¬ e_1)) (¬ e_2)))
           ((∨ e_1) e_2))) BANANA+SPA e))

;; prettify-logic makes logical operators infix and translates
;; lambda-binders to quantifiers.
(define prettify-logic
  (context-closure
    (reduction-relation BANANA+SPA
      (--> ((∧ any_1) any_2)
           (any_1 ∧ any_2))
      (--> ((⇒ any_1) any_2)
           (any_1 ⇒ any_2))
      (--> ((∨ any_1) any_2)
           (any_1 ∨ any_2))
      (--> (∃ (λ (x) any))
           (∃ (x) any))
      (--> (∀ (λ (x) any))
           (∀ (x) any))
      (--> ((c_pred any_1 ...) any_2)
           (c_pred any_1 ... any_2)
           ;; We translate the convention of using boldface to typeset
           ;; logical predicates in the dissertation to the convention of
           ;; using symbols ending with * in this mechanization.
           (side-condition (string-suffix? (symbol->string (term c_pred)) "*"))))
    BANANA+SPAL
    context))

;; compute-truth-conditions combines all the steps necessary to go from
;; a lambda-banana term which encodes the meaning of a sentence to
;; human-readable truth-conditions of that sentence.
(define (compute-truth-conditions term)
  (let* ([normal-form (normalize-bottom-up reduce-more term)]
         [unblocked-form (resolve-blocked normal-form)]
         [simplified (normalize simplify-logic unblocked-form)]
         [pretty (normalize prettify-logic simplified)])
    pretty))



;; Common Combinators
;; ==================
;;
;; This part mirrors Section 1.6 of the dissertation. It introduces
;; syntactic shortcuts, combinators that we will make heavy use of.


;; We define the monadic bind (>>=) of our monad.
(define-metafunction BANANA+SPA
  >>= : e e -> e
  [(>>= e_m e_k)
   (with (η e_k) handle e_m)])

;; The op! syntax lets uses an operation with the trivial continuation
;; (lambda x. eta x).
(define-metafunction BANANA+SPA
  [(! OP)
   (λ (x) (OP x (λ (y) (η y))))]
  [(! OP e)
   (OP e (λ (x) (η x)))])

;; We functionalize OP, i.e. we turn the OP expression constructor into a
;; function expression. Also known as a generic effect.
(define-metafunction BANANA+SPA
  gen : OP -> e
  [(gen OP)
   (λ (x) (λ (k) (OP x (λ (y) (k y)))))])

;; This construction lets us omit the eta clause when writing
;; a handler. The default clause eta: (lambda x. eta x) is used.
(define-metafunction BANANA+SPA
  with-η : (OP e) ... handle e -> e
  [(with-η (OP e_h) ... handle e_arg)
   (with (OP e_h) ... (η (λ (x) (η x))) handle e_arg)])

;; We functionalize handlers. In lambda-banana, this corresponds to writing
;; a handler without giving its argument.
(define-metafunction BANANA+SPA
  handler : (OP e) ... (η e) -> e
  [(handler (OP e_h) ... (η e_p))
   ,(term-let ([x_f (variable-not-in (term (e_h ... e_p)) 'x)])
              (term (λ (x_f) (with (OP e_h) ... (η e_p) handle x_f))))])
;; We combine the two last abstractions to define a functionalized handler
;; expression with the default eta clause.
(define-metafunction BANANA+SPA
  handler-η : (OP e) ... -> e
  [(handler-η (OP e_h) ...)
   ,(term-let ([x_f (variable-not-in (term (e_h ...)) 'x)])
              (term (λ (x_f) (with-η (OP e_h) ... handle x_f))))])

;; We define a syntax for (n-ary) function composition.
(define-metafunction BANANA+SPA
  ∘ : e ... -> e
  ...)

;; We define function application for cases when the function is provided
;; by a computation.
(define-metafunction BANANA+SPA
  <<· : e e -> e
  [(<<· e_f e_x)
   ,(term-let ([x_f (variable-not-in (term e_x) 'f)])
              (term (>>= e_f (λ (x_f) (η (x_f e_x))))))])

;; We also define function application when the argument is the result of
;; a computation.
(define-metafunction BANANA+SPA
  ·>> : e e -> e
  [(·>> e_f e_x)
   ,(term-let ([x_f (variable-not-in (term e_f) 'x)])
              (term (>>= e_x (λ (x_f) (η (e_f x_f))))))])

;; Finally, we define function application for when both function and
;; argument are the results of computations. This is the <*> binary
;; operator of applicative functors.
(define-metafunction BANANA+SPA
  <<·>> : e e -> e
  [(<<·>> e_f e_x)
   ,(term-let ([x_f1 (variable-not-in (term e_x) 'f)]
               [x_f2 (variable-not-in (term x_f1) 'x)])
              (term (>>= e_f (λ (x_f1) (>>= e_x (λ (x_f2) (η (x_f1 x_f2))))))))])

;; When defining the open handler for dynamics (box), we will make use of
;; the following two combinators, introduced in Subsection 7.3.1 of
;; the dissertation.
(define-metafunction BANANA+SPA
  <<<· : e e -> e
  [(<<<· e_f e_x)
   ,(term-let ([x_f (variable-not-in (term e_x) 'f)])
              (term (>>= e_f (λ (x_f) (x_f e_x)))))])

(define-metafunction BANANA+SPA
  ∃>> : e -> e
  [(∃>> e_pred)
   (·>> ∃ (C e_pred))])
