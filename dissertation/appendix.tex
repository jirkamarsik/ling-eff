\Annexes


\Annex{List of Examples}
\label{chap:list-of-examples}

\begin{exe}
  \exr{ex:intro} She might still be dating that idiot.
  \dotfill \pageref{ex:intro}
\end{exe}

\begin{exe}
  \exr{ex:syllogism-hypothesis} Every man is mortal. Socrates is a man.
  \dotfill \pageref{ex:syllogism-hypothesis}
\end{exe}

\begin{exe}
  \exr{ex:syllogism-conclusion} Socrates is mortal.
  \dotfill \pageref{ex:syllogism-conclusion}
\end{exe}

\begin{exe}
  \exr{ex:no-antecedent} It fascinates him.
  \dotfill \pageref{ex:no-antecedent}
\end{exe}

\begin{exe}
  \exr{ex:ulysses} Jones$_1$ owns Ulysses$_2$. It$_2$ fascinates him$_1$.
  \dotfill \pageref{ex:ulysses}
\end{exe}

\begin{exe}
  \exr{ex:jones-porsche} Jones$_1$ owns a Porsche$_2$. It$_2$ fascinates him$_1$.
  \dotfill \pageref{ex:jones-porsche}
\end{exe}

\begin{exe}
  \exr{ex:donkey-rc} Every farmer who owns a donkey$_1$ beats it$_1$.
  \dotfill \pageref{ex:donkey-rc}
\end{exe}

\begin{exe}
  \exr{ex:donkey-if} If a farmer$_1$ owns a donkey$_2$, he$_1$ beats it$_2$.
  \dotfill \pageref{ex:donkey-if}
\end{exe}

\begin{exe}
  \exr{ex:donkey-cruel}[*]{Every farmer$_1$ who owns a donkey$_2$ beats
    it$_2$. He$_1$ is cruel.
  \dotfill \pageref{ex:donkey-cruel}}
\end{exe}

\begin{exe}
  \exr{ex:trivial} John loves Mary.
  \dotfill \pageref{ex:trivial}
\end{exe}

\begin{exe}
  \exr{ex:deixis} John loves me.
  \dotfill \pageref{ex:deixis}
\end{exe}

\begin{exe}
  \exr{ex:indirect-speech} John said Mary loves me.
  \dotfill \pageref{ex:indirect-speech}
\end{exe}

\begin{exe}
  \exr{ex:direct-speech} John said ``Mary loves me''.
  \dotfill \pageref{ex:direct-speech}
\end{exe}

\begin{exe}
  \exr{ex:either-or} Either John loves Sarah, or Mary, John's best friend, loves John.
  \dotfill \pageref{ex:either-or}
\end{exe}

\begin{exe}
  \exr{ex:if-not} If it is not the case that John, whom Sarah loves, loves Sarah then Mary loves John.
  \dotfill \pageref{ex:if-not}
\end{exe}

\begin{exe}
  \exr{ex:quantifiers} Every man loves a woman.
  \dotfill \pageref{ex:quantifiers}
\end{exe}

\begin{exe}
  \exr{ex:siamese} Every owner of a siamese cat loves a therapist.
  \dotfill \pageref{ex:siamese}
\end{exe}

\begin{exe}
  \exr{ex:mixed-nps} John loves a man.
  \dotfill \pageref{ex:mixed-nps}
\end{exe}

\begin{exe}
  \exr{ex:man-porsche} A man owns a Porsche. It fascinates him.
  \dotfill \pageref{ex:man-porsche}
\end{exe}

\begin{exe}
  \exr{ex:jones-mercedes} It is not the case that Jones$_1$ owns a
  Porsche. He$_1$ owns a Mercedes.
  \dotfill \pageref{ex:jones-mercedes}
\end{exe}

\begin{exe}
  \exr{ex:not-john-car} It is not the case that John$_1$ likes his$_1$ car.
  \dotfill \pageref{ex:not-john-car}
\end{exe}

\begin{exe}
  \exr{ex:cancel} If John owns a car, then his car is cheap.
  \dotfill \pageref{ex:cancel}
\end{exe}

\begin{exe}
  \exr{ex:john-presupposed} If there is a poor man called John, then if
  John owns a car, his car is cheap.
  \dotfill \pageref{ex:john-presupposed}
\end{exe}

\begin{exe}
  \exr{ex:wilma} ($c_0$) Maybe ($c_1$) Wilma thinks that ($c_2$) her
  husband is having an affair.
  \dotfill \pageref{ex:wilma}
\end{exe}

\begin{exe}
  \exr{ex:most-germans-wash} Most Germans wash their car on Saturday.
  \dotfill \pageref{ex:most-germans-wash}
\end{exe}

\begin{exe}
  \exr{ex:man-angry} ($c_0$) If ($c_1$) a man gets angry, ($c_2$) his
  children get frightened.
  \dotfill \pageref{ex:man-angry}
\end{exe}

\begin{exe}
  \exr{ex:cataphora}[*]{He$_1$ loves John's$_1$ car.
  \dotfill \pageref{ex:cataphora}}
\end{exe}

\begin{exe}
  \exr{ex:bathroom} Either there's no bathroom$_1$ in the house, or
  it's$_1$ in a funny place.
  \dotfill \pageref{ex:bathroom}
\end{exe}

\begin{exe}
  \exr{ex:hospital} John, who nearly killed a woman$_1$ with his car,
  visited her$_1$ in the hospital.
  \dotfill \pageref{ex:hospital}
\end{exe}

\begin{exe}
  \exr{ex:porridge} The porridge is warm.
  \dotfill \pageref{ex:porridge}
\end{exe}

\begin{exe}
  \exr{ex:crossover}[*]{His$_1$ mother likes every man$_1$.
  \dotfill \pageref{ex:crossover}}
\end{exe}

\begin{exe}
  \exr{ex:inverse} A woman loves every man.
  \dotfill \pageref{ex:inverse}
\end{exe}

\begin{exe}
  \exr{ex:primary-crossover}[*]{He$_1$ likes every man$_1$.
  \dotfill \pageref{ex:primary-crossover}}
\end{exe}

\begin{exe}
  \exr{ex:secondary-crossover}[*]{He$_1$ likes every man$_1$'s mother.
  \dotfill \pageref{ex:secondary-crossover}}
\end{exe}

\begin{exe}
  \exr{ex:bad-crossover}[*]{It$_1$ loves every owner of a dog$_1$.
  \dotfill \pageref{ex:bad-crossover}}
\end{exe}

\begin{exe}
  \exr{ex:presupposition-binding} The man who owns a dog$_1$ loves it$_1$.
  \dotfill \pageref{ex:presupposition-binding}
\end{exe}

\begin{exe}
  \exr{ex:presupposition-binding2} The man$_1$ who loves his$_1$ dog$_2$
  treats it$_2$ well.
  \dotfill \pageref{ex:presupposition-binding2}
\end{exe}

\begin{exe}
  \exr{ex:presupposition-every-narrow} The owner of every book ever
  published by Elsevier must be very rich.
  \dotfill \pageref{ex:presupposition-every-narrow}
\end{exe}

\begin{exe}
  \exr{ex:presupposition-every-wide} Mary sent an email to the
  representative of every country.
  \dotfill \pageref{ex:presupposition-every-wide}
\end{exe}

\begin{exe}
  \exr{ex:every-presupposition} Everyone$_1$ hates the sound of their$_1$
  voice.
  \dotfill \pageref{ex:every-presupposition}
\end{exe}

\begin{exe}
  \exr{ex:binding-in-presupposition} John met the woman who stole a car$_1$
  by hacking into its$_1$ computer.
  \dotfill \pageref{ex:binding-in-presupposition}
\end{exe}

\begin{exe}
  \exr{ex:combo} My best friend, who owns a dog$_1$, said it$_1$ loves everyone.
  \dotfill \pageref{ex:combo}
\end{exe}

\begin{exe}
  \exr{ex:C-operator} A man$_1$ walks in the park. He$_1$ whistles.
  \dotfill \pageref{ex:C-operator}
\end{exe}

\begin{exe}
  \exr{ex:mary-peter} Peter said ``Mary kissed me''.
  \dotfill \pageref{ex:mary-peter}
\end{exe}

\begin{exe}
  \exr{ex:peter-mary} Peter said ``I was kissed by Mary''.
  \dotfill \pageref{ex:peter-mary}
\end{exe}

\begin{exe}
  \exr{ex:modal-subordination} A wolf$_1$ might walk in. It$_1$ would growl.
  \dotfill \pageref{ex:modal-subordination}
\end{exe}

\begin{exe}
  \exr{ex:salmon}[*]{John had a great evening last night. He had a great
    meal. He ate salmon$_1$. He devoured lots of cheese. He then won a
    dancing competition. It$_1$ was pink.
  \dotfill \pageref{ex:salmon}}
\end{exe}



\Annex{Example from the Final Fragment}
\label{chap:final-example}

We dedicate this chapter to the following sentence:

\begin{exe}
  \exr{ex:combo} My best friend, who owns a dog$_1$, said it$_1$ loves
  everyone.
\end{exe}

This sentence features all of the aspects of language that we covered in
Part~\ref{part:natural-language}:

\begin{itemize}
\item we have the deictic first-person pronoun \emph{my}
\item we have the presupposition triggering noun phrase \emph{my best
    friend}
\item we have the appositive relative clause \emph{who owns a dog}
\item we have the anaphoric pronoun \emph{it}, which is bound by an
  indefinite inside an appositive
\item we have the quantificational noun phrase \emph{everyone}
\end{itemize}

As with the examples in Chapter~\ref{chap:dynamic-semantics}, we will
proceed by incrementally building up the meanings of the parts of the
sentence. We start with the clause \emph{it loves everyone}. First, we
introduce the noun phrase $\abs{everyone} : NP$, which can be seen as a
special case of the $\abs{every} : N \limp NP$ determiner that already
exists in our grammar.

\begin{align*}
  \abs{everyone} &: NP \\
  \sem{\abs{everyone}} &= \app{\op{scope}}{\dforall}{(\lam{x}{\etaE{(\ap{\trace}{x})}})}
\end{align*}

Now, we move to the clause. The entry for the transitive verb \emph{loves}
tells us to evaluate the subject and the object, to assert that the
relation $\obj{love}$ holds for the two, and to handle any $\op{scope}$
operations using $\SI$ to enforce the ``tensed clauses are scope islands''
constraint.

\begin{align*}
  &\sem{\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}}} \\
  &\tto \ap{\SI}{(\begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\app{\op{scope}}{\dforall}{(\lam{z}{ \\
      &\app{\op{push}}{z}{(\lam{\_}{ \\
      &\app{\op{assert}}{(\app{\obj{love}}{(\ap{\selit}{e})}{z})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}})})
    \end{aligned}} \\
  &\tto \begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\ap{\dforall}{(\lam{z}{\app{\op{push}}{z}{(\lam{\_}{\ap{\op{assert}!}{(\app{\obj{love}}{(\ap{\selit}{e})}{z})}})}})}})}
    \end{aligned} \\
  &\tto \begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\app{\op{assert}}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}
    \end{aligned}
\end{align*}

We will now give a meaning to the verb phrase \emph{said it loves
  everyone}. The verb \emph{said} evaluates its complementary clause down
to a proposition using the $\BOX$ handler. We will therefore first
calculate the value of applying $\BOX$ to the meaning of \emph{it loves
  everyone}.

\begin{align*}
  &\ap{\BOX}{\sem{\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}}}} \\
  &\tto \ap{\BOX}{(\begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\app{\op{assert}}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}\,)
    \end{aligned}} \\
  &\tto \begin{aligned}[t]
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\etaE{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})}})}
    \end{aligned}
\end{align*}

We can now plug this result into the lexical entry $\abs{said}_{\abs{is}}$.

\begin{align*}
  &\sem{\ap{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}} \\
  &\tto \lam{X}{\ap{\SI}{(\begin{aligned}[t]
        &X \hsbind (\lam{x}{ \\
        &\app{\op{get}}{\star}{(\lam{e}{ \\
        &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
        &\etaE{\star}})}})}})\,)
      \end{aligned}}}
\end{align*}

Now we move to the subject of the sentence. The meaning of the first-person
pronoun \emph{me} is obtained by asking the context for the identity of the
speaker and the meaning of the possessive construction \emph{X's best
  friend} is obtained by asking the context for an individual that is $X$'s
best friend. To obtain the meaning of the noun phrase \emph{my best
  friend}, it suffices to chain/concatenate the two computations.

\begin{align*}
  &\sem{\ap{\abs{best-friend}}{\abs{me}}} \\
  &\tto \begin{aligned}[t]
      &\app{\op{speaker}}{\star}{(\lam{s}{ \\
      &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
      &\etaE{x}})}})}
    \end{aligned}
\end{align*}

Next, we compute the meaning of the verb phrase \emph{owns a dog} that
occurs in the relative clause. The indefinite \emph{a dog} introduces a
discourse referent which it claims to be a dog.

\begin{align*}
  &\sem{\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})}} \\
  &\tto \lam{X}{\ap{\SI}{(\begin{aligned}[t]
      &X \hsbind (\lam{x}{ \\
      &\app{\op{introduce}}{\star}{(\lam{y}{ \\
      &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}})\,)
    \end{aligned}}}
\end{align*}

According to the lexical entry for $\abs{who}_{\abs{s}}$, the verb phrase
inside an appositive relative clause is applied to a variable $x$ and
passed through the $\asImplicature$, which moves the contents of the
relative clause from the at-issue layer to the layer of conventional
implicatures.

\begin{align*}
  &\ap{\asImplicature}{\sem{\app{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})}{(\etaE{x})}}} \\
  &\tto \ap{\asImplicature}{(\begin{aligned}[t]
      &\app{\op{introduce}}{\star}{(\lam{y}{ \\
      &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}\,)
    \end{aligned}} \\
  &\tto \begin{aligned}[t]
      &\app{\op{introduce^i}}{\star}{(\lam{y}{ \\
      &\app{\op{implicate}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{implicate}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}
    \end{aligned}
\end{align*}

To get the meaning of the noun phrase \emph{my best friend} as modified by
the appositive relative clause \emph{who owns a dog}, we chain their
computations.

\begin{align*}
  &\sem{\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})}} \\
  &\tto \begin{aligned}[t]
      &\app{\op{speaker}}{\star}{(\lam{s}{ \\
      &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
      &\app{\op{introduce^i}}{\star}{(\lam{y}{ \\
      &\app{\op{implicate}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{implicate}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\etaE{x}})}})}})}})}})}
    \end{aligned}
\end{align*}

Finally, to compute the meaning of the whole sentence of
Example~\ref{ex:combo}, we chain the computation of the subject with the
computation of the verb phrase.

\begin{align*}
& \sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}} \\
& \tto \begin{aligned}[t]
      &\app{\op{speaker}}{\star}{(\lam{s}{ \\
      &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
      &\app{\op{introduce^i}}{\star}{(\lam{y}{ \\
      &\app{\op{implicate}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
      &\app{\op{implicate}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
      &\app{\op{get}}{\star}{(\lam{e}{ \\
      &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
      &\etaE{\star}})}})}})}})}})}})}})}
    \end{aligned}
\end{align*}

We now have all the instructions that tell us how to find the truth
conditions of the sentence within any context. We can use the handler
$\ap{\TOP}{s}$ to get the meaning of the sentence within an ``empty''
context with the speaker $s$. The $\TOP$ handler is defined as a
composition of all the partial handlers for the different aspects of our
fragment. We will apply the handlers to the meaning of
Example~\ref{ex:combo} one by one.

\begin{align*}
  \TOP &: \iota \to \FF_E(1) \to \FF_\emptyset(o) \\
  \TOP &= \lam{s}{\search \comp \EMPTY \comp \BOX \comp \accommodate \comp \useFind \comp \withImplicatures \comp \ap{\withSpeaker}{s} \comp \SI}
\end{align*}

We label the meaning of Example~\ref{ex:combo} as $t_0$ and the successive
applications of the handlers as $t_1$, $t_2$\ldots

$$
t_0 = \sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}}
$$

We start with the $\SI$ handler. Since the computation $t_0$ uses no
$\op{scope}$ operation, the $\SI$ handler will have no effect.

$$
t_1 = \ap{\SI}{t_0} \tto t_0
$$

Next up is the $\ap{\withSpeaker}{s}$ handler. This will resolve the
$\op{speaker}$ operation by replacing the speaker variable $s$ by the
hypothetical speaker $s$, i.e.\ the rest of the computation stays the same.

\begin{align*}
  t_2 = \app{\withSpeaker}{s}{t_1} \tto \ 
  &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
  &\app{\op{introduce^i}}{\star}{(\lam{y}{ \\
  &\app{\op{implicate}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
  &\app{\op{implicate}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
  &\etaE{\star}})}})}})}})}})}})}
\end{align*}

Then we have the $\withImplicatures$ handler that will accommodate the
implicatures of the sentence as part of its truth conditions.

\begin{align*}
  t_3 = \ap{\withImplicatures}{t_2} \tto \ 
  &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
  &\app{\op{introduce}}{\star}{(\lam{y}{ \\
  &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
  &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
  &\etaE{\star}})}})}})}})}})}})}
\end{align*}

Next is the $\useFind$ handler that will try to look up a referent for the
speaker's best friend within the context.

\begin{align*}
  t_4 = \ap{\useFind}{t_3} \tto \
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &(\casenl{\app{\selP}{(\lam{x}{\app{\obj{best-friend}}{x}{s}})}{e}}
       {x}{\etaE{x}}
       {\_}{\ap{\op{presuppose}!}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}}) \hsbind (\lam{x}{ \\
  &\app{\op{introduce}}{\star}{(\lam{y}{ \\
  &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
  &\app{\op{asssert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
  &\etaE{\star}})}})}})}})}})}})})}
\end{align*}

We know ahead of time that the context $e$ in which the sentence will be
evaluated will not contain the speaker's best friend and so we allow
ourselves to reduce
$\app{\selP}{(\lam{x}{\app{\obj{best-friend}}{x}{s}})}{e}$ to
$\ap{\inr}{\star}$.

\begin{align*}
  t_4 \tto\ 
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{presuppose}}{(\lam{x}{\ap{\op{assert}!}{(\app{\obj{best-friend}}{x}{s})}})}{(\lam{x}{ \\
  &\app{\op{introduce}}{\star}{(\lam{y}{ \\
  &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
  &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
  &\etaE{\star}})}})}})}})}})}})}})}
\end{align*}

The presupposition is then accommodated by the $\accommodate$ handler.

\begin{align*}
  t_5 = \ap{\accommodate}{t_4} \tto \ 
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{introduce}}{\star}{(\lam{x}{ \\
  &\app{\op{assert}}{(\app{\obj{best-friend}}{x}{s})}{(\lam{\_}{ \\
  &\app{\op{introduce}}{\star}{(\lam{y}{ \\
  &\app{\op{assert}}{(\ap{\obj{dog}}{y})}{(\lam{\_}{ \\
  &\app{\op{assert}}{(\app{\obj{own}}{x}{y})}{(\lam{\_}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{assert}}{(\app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e})}{z})})}{(\lam{\_}{ \\
  &\etaE{\star}})}})}})}})}})}})}})}})}
\end{align*}

Next up is the $\BOX$ handler which takes care of the sentence dynamics.

\begin{align*}
  t_6 = \ap{\BOX}{t_5} \tto \
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\app{\op{get}}{\star}{(\lam{e}{ \\
  &\etaE{(\exists x.\, \app{\obj{best-friend}}{x}{s} \land
          (\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land
           \app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e'})}{z})}))}})}})}
\end{align*}

where

$$
e' = ((\app{\obj{own}}{x}{y}) \cons (\ap{\obj{dog}}{y}) \cons y \cons
(\app{\obj{best-friend}}{x}{s}) \cons x \cons \nil) \cat e
$$

The $\EMPTY$ handler, which comes next, will identify the (anaphoric)
context $e$ in which the sentence is being evaluated as the empty context
$\nil$.

\begin{align*}
  t_7 = \ap{\EMPTY}{t_6} \tto \
  &\etaE{(\exists x.\, \app{\obj{best-friend}}{x}{s} \land
          (\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land
           \app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{(\ap{\selit}{e''})}{z})}))}
\end{align*}

where

\begin{align*}
e'' &= ((\app{\obj{own}}{x}{y}) \cons (\ap{\obj{dog}}{y}) \cons y \cons
(\app{\obj{best-friend}}{x}{s}) \cons x \cons \nil) \cat \nil \\
    &= (\app{\obj{own}}{x}{y}) \cons (\ap{\obj{dog}}{y}) \cons y \cons
(\app{\obj{best-friend}}{x}{s}) \cons x \cons \nil
\end{align*}

The context $e''$ contains only two entities: the speaker's best friend $x$
and his dog $y$. Assuming that anaphora resolution will choose the dog $y$
as the referent of the pronoun \emph{it}, we can reduce $\ap{\selit}{e''}$
to $y$.

\begin{align*}
  &t_7 = \app{\TOP}{s}{\sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}}} \\
  &\tto \etaE{(\exists x.\, \app{\obj{best-friend}}{x}{s} \land
              (\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land
               \app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{y}{z})}))}
\end{align*}

By applying the $\ap{\TOP}{s}$ composition of handlers, we have interpreted
away all the operations. The result is of the form $\etaE{A}$ where $A$ are
the truth conditions of the sentence. To retrieve $A$ from $\etaE{A}$, we
can use $\cherry$.

\begin{align*}
& \ap{\cherry}{t_7} = \ap{\cherry}{(\app{\TOP}{s}{\sem{\app{\abs{said}_{\abs{is}}}{(\app{\abs{loves}}{(\ap{\abs{in-situ}}{\abs{everyone}})}{\abs{it}})}{(\app{\abs{who}_{\abs{s}}}{(\ap{\abs{owns}}{(\ap{\abs{a}}{\abs{dog}})})}{(\ap{\abs{best-friend}}{\abs{me}})})}}})} \\
& \tto \exists x.\, \app{\obj{best-friend}}{x}{s} \land (\exists y.\, \ap{\obj{dog}}{y} \land \app{\obj{own}}{x}{y} \land \app{\obj{say}}{x}{(\forall z.\, \app{\obj{love}}{y}{z})})
\end{align*}



\Annex[Computer Mechanization of the Calculus]{Computer Mechanization \\ of the Calculus}
\label{chap:mechanization}

During the development of our approach, we have experimented with several
implementations of effects and handlers. In our initial explorations, we
used Kiselyov's extensible effects Haskell
library~\cite{kiselyov2013extensible,extensible-effects}. However, this
made it difficult to separate our contribution from the details of the
Haskell encoding of effects and handlers. In the next step, we turned to a
programming language which included effects and handlers as first-class
primitives, Bauer and Pretnar's \emph{Eff}~\cite{bauer2012programming}. We
have used \emph{Eff} to prototype the grammars which led to us reporting
our first results with effects and handlers in natural
language~\cite{marsik2014algebraic}. Nevertheless, we found it difficult to
develop larger grammars in a direct-style calculus without a suitable
effect system.

We designed $\calc$ to have a calculus in which evaluation (reduction) is
independent of execution (the ordering of effects within
computations). After the definition of $\calc$ started to stabilize, we
looked at ways of mechanizing the calculus so as to be able to use a
computer to assist us in exploring the calculus. $\calc$ is defined by a
set of reduction rules and so we have used PLT
Redex~\cite{felleisen2009semantics} to develop the mechanization of the
calculus. Redex is a Racket library/domain-specific language for
engineering and debugging reduction semantics. The formal language of terms
and types, the typing rules and the reduction rules can all be written in a
style close to the one used in academic papers. The formalization can then
be used to automatically generate test cases for formal properties such as
subject reduction, termination or progress.

We have formalized the syntax, typing rules and reduction rules using
Redex. The source code can be found at:

\centerline{\url{https://github.com/jirkamarsik/ling-eff/blob/master/redex/effects-and-handlers.rkt}}

However, in order to be able to define the typing rules as judgment forms
within Redex, we needed to include type annotations in our terms. Since
$\calc$ types include computation types, which are indexed by effect
signatures, which contain more types, the type-annotated terms become
unwieldy. We have therefore also developed a formalization which omits the
type system but keeps the original syntax. This second formalization can be
found at:

\centerline{\url{https://github.com/jirkamarsik/ling-eff/blob/master/redex/untyped-bananas.rkt}}

We have commented this formalization and we have also included the complete
final grammar that we introduce in
Chapter~\ref{chap:composing-effects}. This formalization still leaves much
to be desired: normalizing a $\calc$ term which corresponds to a
non-trivial linguistic example can easily take half an hour.\footnote{The
  Redex library only allows us to compute \emph{all} of the possible
  reduction steps going from a given term. Since after expanding all the
  syntactic sugar, the auxiliary handlers and other combinators, the
  $\calc$ terms that compute the meaning of an entire sentence can be very
  large, the atomic Redex operation of finding all the reductions in a term
  becomes costly.} The formalization is therefore not suitable for rapid
prototyping of semantic grammars. However, we can still use the
formalization as a source of machine proofs for reductions in $\calc$. For
example, we can use the formalization to verify the predicted meaning of
Example~\ref{ex:combo} from Appendix~\ref{chap:final-example}. In the rest
of the appendix, we present an edited version of this formalization.
\newpage

\setmonofont{DejaVu Sans Mono}

\inputminted{racket}{redex/intro.rkt}
\newpage
\inputminted{racket}{redex/reduce.rkt}
\newpage
\inputminted{racket}{redex/anaphora.rkt}
\newpage
\inputminted{racket}{redex/code.rkt}
\newpage
\inputminted{racket}{redex/extend-ops.rkt}
\newpage
\inputminted{racket}{redex/handlers.rkt}
\newpage
\inputminted{racket}{redex/grammar.rkt}
